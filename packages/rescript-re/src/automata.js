// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "@rescript/std/lib/es6/caml.js";
import * as Cset from "./cset.js";
import * as List from "@rescript/std/lib/es6/list.js";
import * as $$Array from "@rescript/std/lib/es6/array.js";
import * as Curry from "@rescript/std/lib/es6/curry.js";
import * as Pmark from "./pmark.js";
import * as Format from "./Format.js";
import * as Hashtbl from "@rescript/std/lib/es6/hashtbl.js";
import * as Caml_obj from "@rescript/std/lib/es6/caml_obj.js";
import * as Category from "./category.js";
import * as Caml_array from "@rescript/std/lib/es6/caml_array.js";

function hash_combine(h, accu) {
  return Math.imul(accu, 65599) + h | 0;
}

var empty_pmarks = Pmark.$$Set.empty;

var empty = {
  marks: /* [] */0,
  pmarks: empty_pmarks
};

function merge_marks_offset(old, param) {
  if (!param) {
    return old;
  }
  var match = param.hd;
  var v = match[1];
  var i = match[0];
  var nw$p = merge_marks_offset(List.remove_assq(i, old), param.tl);
  if (v === -2) {
    return nw$p;
  } else {
    return {
            hd: [
              i,
              v
            ],
            tl: nw$p
          };
  }
}

function merge(old, nw) {
  return {
          marks: merge_marks_offset(old.marks, nw.marks),
          pmarks: Curry._2(Pmark.$$Set.union, old.pmarks, nw.pmarks)
        };
}

function hash_marks_offset(_l, _accu) {
  while(true) {
    var accu = _accu;
    var l = _l;
    if (!l) {
      return accu;
    }
    var match = l.hd;
    _accu = hash_combine(match[0], hash_combine(match[1], accu));
    _l = l.tl;
    continue ;
  };
}

function hash(m, accu) {
  return hash_marks_offset(m.marks, hash_combine(Hashtbl.hash(m.pmarks), accu));
}

function marks_set_idx(idx, marks) {
  if (!marks) {
    return marks;
  }
  var match = marks.hd;
  if (match[1] !== -1) {
    return marks;
  } else {
    return {
            hd: [
              match[0],
              idx
            ],
            tl: marks_set_idx(idx, marks.tl)
          };
  }
}

function marks_set_idx$1(marks, idx) {
  return {
          marks: marks_set_idx(idx, marks.marks),
          pmarks: marks.pmarks
        };
}

function pp_marks(ch, t) {
  var match = t.marks;
  if (!match) {
    return ;
  }
  var match$1 = match.hd;
  console.log(ch, "%d-%d", match$1[0], match$1[1]);
  return List.iter((function (param) {
                console.log(ch, " %d-%d", param[0], param[1]);
                
              }), match.tl);
}

var Marks = {
  empty: empty,
  merge_marks_offset: merge_marks_offset,
  merge: merge,
  hash_marks_offset: hash_marks_offset,
  hash: hash,
  marks_set_idx: marks_set_idx$1,
  pp_marks: pp_marks
};

function pp_sem(ch, k) {
  return Format.pp_print_string(ch, k === "Longest" ? "long" : (
                k === "First" ? "first" : "short"
              ));
}

function pp_rep_kind(fmt, param) {
  if (param === "Non_greedy") {
    return Format.pp_print_string(fmt, "Non_greedy");
  } else {
    return Format.pp_print_string(fmt, "Greedy");
  }
}

function print_one(ch, param) {
  var c2 = param[1];
  var c1 = param[0];
  if (Caml_obj.caml_equal(c1, c2)) {
    console.log(ch, "%d", c1);
  } else {
    console.log(ch, "%d-%d", c1, c2);
  }
  
}

function pp(ch, e) {
  var l = e.def;
  if (typeof l === "number") {
    console.log(ch, "eps");
    return ;
  }
  switch (l.TAG | 0) {
    case /* Cst */0 :
        console.log(ch, "cst", Cset.pp, l._0);
        return ;
    case /* Alt */1 :
        console.log(ch, "alt", (console.log(pp), undefined), l._0);
        return ;
    case /* Seq */2 :
        console.log(ch, "seq", (function (param) {
                console.log(pp_sem, pp, pp, param);
                
              }), [
              l._0,
              l._1,
              l._2
            ]);
        return ;
    case /* Rep */3 :
        console.log(ch, "rep", (console.log(pp_sem, pp), undefined), [
              l._1,
              l._2
            ]);
        return ;
    case /* Mark */4 :
        console.log(ch, "mark", l._0);
        return ;
    case /* Erase */5 :
        console.log(ch, "erase", l._0, l._1);
        return ;
    case /* Before */6 :
        console.log(ch, "before", Category.pp, l._0);
        return ;
    case /* After */7 :
        console.log(ch, "after", Category.pp, l._0);
        return ;
    case /* Pmark */8 :
        console.log(ch, "pmark", l._0);
        return ;
    
  }
}

function first(f, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var res = Curry._1(f, param.hd);
    if (res !== undefined) {
      return res;
    }
    _param = param.tl;
    continue ;
  };
}

function create_ids(param) {
  return {
          contents: 0
        };
}

var eps_expr = {
  id: 0,
  def: /* Eps */0
};

function mk_expr(ids, def) {
  ids.contents = ids.contents + 1 | 0;
  return {
          id: ids.contents,
          def: def
        };
}

function empty$1(ids) {
  return mk_expr(ids, {
              TAG: /* Alt */1,
              _0: /* [] */0
            });
}

function cst(ids, s) {
  if (Cset.is_empty(s)) {
    return mk_expr(ids, {
                TAG: /* Alt */1,
                _0: /* [] */0
              });
  } else {
    return mk_expr(ids, {
                TAG: /* Cst */0,
                _0: s
              });
  }
}

function alt(ids, l) {
  if (l) {
    if (l.tl) {
      return mk_expr(ids, {
                  TAG: /* Alt */1,
                  _0: l
                });
    } else {
      return l.hd;
    }
  } else {
    return mk_expr(ids, {
                TAG: /* Alt */1,
                _0: /* [] */0
              });
  }
}

function seq(ids, kind, x, y) {
  var match = x.def;
  var match$1 = y.def;
  var exit = 0;
  if (typeof match === "number") {
    return y;
  }
  if (match.TAG === /* Alt */1) {
    if (!match._0) {
      return x;
    }
    exit = 2;
  } else {
    exit = 2;
  }
  if (exit === 2) {
    if (typeof match$1 === "number") {
      if (kind === "First") {
        return x;
      }
      
    } else if (match$1.TAG === /* Alt */1 && !match$1._0) {
      return y;
    }
    
  }
  return mk_expr(ids, {
              TAG: /* Seq */2,
              _0: kind,
              _1: x,
              _2: y
            });
}

function is_eps(expr) {
  var match = expr.def;
  if (typeof match === "number") {
    return true;
  } else {
    return false;
  }
}

function eps(ids) {
  return mk_expr(ids, /* Eps */0);
}

function rep(ids, kind, sem, x) {
  return mk_expr(ids, {
              TAG: /* Rep */3,
              _0: kind,
              _1: sem,
              _2: x
            });
}

function mark(ids, m) {
  return mk_expr(ids, {
              TAG: /* Mark */4,
              _0: m
            });
}

function pmark(ids, i) {
  return mk_expr(ids, {
              TAG: /* Pmark */8,
              _0: i
            });
}

function erase(ids, m, m$p) {
  return mk_expr(ids, {
              TAG: /* Erase */5,
              _0: m,
              _1: m$p
            });
}

function before(ids, c) {
  return mk_expr(ids, {
              TAG: /* Before */6,
              _0: c
            });
}

function after(ids, c) {
  return mk_expr(ids, {
              TAG: /* After */7,
              _0: c
            });
}

function rename(ids, x) {
  var l = x.def;
  if (typeof l === "number") {
    return mk_expr(ids, x.def);
  }
  switch (l.TAG | 0) {
    case /* Alt */1 :
        return mk_expr(ids, {
                    TAG: /* Alt */1,
                    _0: List.map((function (param) {
                            return rename(ids, param);
                          }), l._0)
                  });
    case /* Seq */2 :
        return mk_expr(ids, {
                    TAG: /* Seq */2,
                    _0: l._0,
                    _1: rename(ids, l._1),
                    _2: rename(ids, l._2)
                  });
    case /* Rep */3 :
        return mk_expr(ids, {
                    TAG: /* Rep */3,
                    _0: l._0,
                    _1: l._1,
                    _2: rename(ids, l._2)
                  });
    default:
      return mk_expr(ids, x.def);
  }
}

function equal(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      if (l2) {
        return false;
      } else {
        return true;
      }
    }
    var marks1 = l1.hd;
    switch (marks1.TAG | 0) {
      case /* TSeq */0 :
          if (!l2) {
            return false;
          }
          var match = l2.hd;
          switch (match.TAG | 0) {
            case /* TSeq */0 :
                if (marks1._1.id !== match._1.id) {
                  return false;
                }
                if (!equal(marks1._0, match._0)) {
                  return false;
                }
                _l2 = l2.tl;
                _l1 = l1.tl;
                continue ;
            case /* TExp */1 :
            case /* TMatch */2 :
                return false;
            
          }
      case /* TExp */1 :
          if (!l2) {
            return false;
          }
          var match$1 = l2.hd;
          switch (match$1.TAG | 0) {
            case /* TExp */1 :
                if (marks1._1.id !== match$1._1.id) {
                  return false;
                }
                if (!Caml_obj.caml_equal(marks1._0, match$1._0)) {
                  return false;
                }
                _l2 = l2.tl;
                _l1 = l1.tl;
                continue ;
            case /* TSeq */0 :
            case /* TMatch */2 :
                return false;
            
          }
      case /* TMatch */2 :
          if (!l2) {
            return false;
          }
          var marks2 = l2.hd;
          switch (marks2.TAG | 0) {
            case /* TSeq */0 :
            case /* TExp */1 :
                return false;
            case /* TMatch */2 :
                if (!Caml_obj.caml_equal(marks1._0, marks2._0)) {
                  return false;
                }
                _l2 = l2.tl;
                _l1 = l1.tl;
                continue ;
            
          }
      
    }
  };
}

function hash$1(_l, _accu) {
  while(true) {
    var accu = _accu;
    var l = _l;
    if (!l) {
      return accu;
    }
    var marks = l.hd;
    switch (marks.TAG | 0) {
      case /* TSeq */0 :
          _accu = hash_combine(388635598, hash_combine(marks._1.id, hash$1(marks._0, accu)));
          _l = l.tl;
          continue ;
      case /* TExp */1 :
          _accu = hash_combine(726404471, hash_combine(marks._1.id, hash(marks._0, accu)));
          _l = l.tl;
          continue ;
      case /* TMatch */2 :
          _accu = hash_combine(471882453, hash(marks._0, accu));
          _l = l.tl;
          continue ;
      
    }
  };
}

function texp(marks, x) {
  return {
          TAG: /* TExp */1,
          _0: marks,
          _1: x
        };
}

function tseq(kind, x, y, rem) {
  if (!x) {
    return rem;
  }
  var match = x.hd;
  switch (match.TAG | 0) {
    case /* TExp */1 :
        if (typeof match._1.def === "number" && !x.tl) {
          return {
                  hd: {
                    TAG: /* TExp */1,
                    _0: match._0,
                    _1: y
                  },
                  tl: rem
                };
        }
        break;
    case /* TSeq */0 :
    case /* TMatch */2 :
        break;
    
  }
  return {
          hd: {
            TAG: /* TSeq */0,
            _0: x,
            _1: y,
            _2: kind
          },
          tl: rem
        };
}

function print_state_rec(ch, e, y) {
  switch (e.TAG | 0) {
    case /* TSeq */0 :
        var x = e._1;
        console.log(ch, "@[<2>(Seq@ ");
        print_state_lst(ch, e._0, x);
        console.log(ch, "@ %a)@]", pp, x);
        return ;
    case /* TExp */1 :
        var x$1 = e._1;
        var marks = e._0;
        if (typeof x$1.def === "number") {
          console.log(ch, "@[<2>(Exp@ %d@ (%a)@ (eps))@]", String(y.id), pp_marks, marks);
        } else {
          console.log(ch, "@[<2>(Exp@ %d@ (%a)@ %a)@]", String(x$1.id), pp_marks, marks, x$1);
        }
        return ;
    case /* TMatch */2 :
        console.log(ch, "@[<2>(Match@ %a)@]", pp_marks, e._0);
        return ;
    
  }
}

function print_state_lst(ch, l, y) {
  if (l) {
    print_state_rec(ch, l.hd, y);
    return List.iter((function (e) {
                  console.log(ch, "@ | ");
                  return print_state_rec(ch, e, y);
                }), l.tl);
  } else {
    console.log(ch, "()");
    return ;
  }
}

function pp$1(ch, t) {
  return print_state_lst(ch, {
              hd: t,
              tl: /* [] */0
            }, {
              id: 0,
              def: /* Eps */0
            });
}

var E = {
  equal: equal,
  hash: hash$1,
  texp: texp,
  tseq: tseq,
  print_state_rec: print_state_rec,
  print_state_lst: print_state_lst,
  pp: pp$1
};

var dummy = {
  idx: -1,
  category: Category.dummy,
  desc: /* [] */0,
  status: undefined,
  hash: -1
};

function hash$2(idx, cat, desc) {
  return hash$1(desc, hash_combine(idx, hash_combine(Category.to_int(cat), 0))) & 1073741823;
}

function mk(idx, cat, desc) {
  return {
          idx: idx,
          category: cat,
          desc: desc,
          status: undefined,
          hash: hash$2(idx, cat, desc)
        };
}

function create(cat, e) {
  return mk(0, cat, {
              hd: {
                TAG: /* TExp */1,
                _0: empty,
                _1: e
              },
              tl: /* [] */0
            });
}

function equal$1(x, y) {
  if (x.hash === y.hash && x.idx === y.idx && Category.equal(x.category, y.category)) {
    return equal(x.desc, y.desc);
  } else {
    return false;
  }
}

function compare(x, y) {
  var c = Caml.caml_int_compare(x.hash, y.hash);
  if (c !== 0) {
    return c;
  }
  var c$1 = Category.compare(x.category, y.category);
  if (c$1 !== 0) {
    return c$1;
  } else {
    return Caml_obj.caml_compare(x.desc, y.desc);
  }
}

function hash$3(t) {
  return t.hash;
}

var Table = Hashtbl.Make({
      equal: equal$1,
      hash: hash$3
    });

var State = {
  dummy: dummy,
  hash: hash$2,
  mk: mk,
  create: create,
  equal: equal$1,
  compare: compare,
  Table: Table
};

function create_working_area(param) {
  return {
          contents: [false]
        };
}

function index_count(w) {
  return w.contents.length;
}

function reset_table(a) {
  return $$Array.fill(a, 0, a.length, false);
}

function mark_used_indices(tbl) {
  return function (param) {
    return List.iter((function (param) {
                  switch (param.TAG | 0) {
                    case /* TSeq */0 :
                        return mark_used_indices(tbl)(param._0);
                    case /* TExp */1 :
                    case /* TMatch */2 :
                        break;
                    
                  }
                  return List.iter((function (param) {
                                var i = param[1];
                                if (i >= 0) {
                                  return Caml_array.set(tbl, i, true);
                                }
                                
                              }), param._0.marks);
                }), param);
  };
}

function find_free(tbl, _idx, len) {
  while(true) {
    var idx = _idx;
    if (idx === len || !Caml_array.get(tbl, idx)) {
      return idx;
    }
    _idx = idx + 1 | 0;
    continue ;
  };
}

function free_index(tbl_ref, l) {
  var tbl = tbl_ref.contents;
  reset_table(tbl);
  mark_used_indices(tbl)(l);
  var len = tbl.length;
  var idx = find_free(tbl, 0, len);
  if (idx === len) {
    tbl_ref.contents = Caml_array.make((len << 1), false);
  }
  return idx;
}

var remove_matches = List.filter(function (param) {
      switch (param.TAG | 0) {
        case /* TSeq */0 :
        case /* TExp */1 :
            return true;
        case /* TMatch */2 :
            return false;
        
      }
    });

function split_at_match_rec(_l$p, _param) {
  while(true) {
    var param = _param;
    var l$p = _l$p;
    if (param) {
      var x = param.hd;
      switch (x.TAG | 0) {
        case /* TSeq */0 :
        case /* TExp */1 :
            _param = param.tl;
            _l$p = {
              hd: x,
              tl: l$p
            };
            continue ;
        case /* TMatch */2 :
            return [
                    List.rev(l$p),
                    remove_matches(param.tl)
                  ];
        
      }
    } else {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "automata.re",
              447,
              10
            ],
            Error: new Error()
          };
    }
  };
}

function split_at_match(l) {
  return split_at_match_rec(/* [] */0, l);
}

function remove_duplicates(prev, _l, y) {
  while(true) {
    var l = _l;
    if (!l) {
      return [
              /* [] */0,
              prev
            ];
    }
    var x = l.hd;
    switch (x.TAG | 0) {
      case /* TSeq */0 :
          var x$1 = x._1;
          var match = remove_duplicates(prev, x._0, x$1);
          var match$1 = remove_duplicates(match[1], l.tl, y);
          return [
                  tseq(x._2, match[0], x$1, match$1[0]),
                  match$1[1]
                ];
      case /* TExp */1 :
          var x$2 = x._1;
          if (typeof x$2.def === "number") {
            var r = l.tl;
            if (List.memq(y.id, prev)) {
              _l = r;
              continue ;
            }
            var match$2 = remove_duplicates({
                  hd: y.id,
                  tl: prev
                }, r, y);
            return [
                    {
                      hd: x,
                      tl: match$2[0]
                    },
                    match$2[1]
                  ];
          }
          var r$1 = l.tl;
          if (List.memq(x$2.id, prev)) {
            _l = r$1;
            continue ;
          }
          var match$3 = remove_duplicates({
                hd: x$2.id,
                tl: prev
              }, r$1, y);
          return [
                  {
                    hd: x,
                    tl: match$3[0]
                  },
                  match$3[1]
                ];
      case /* TMatch */2 :
          return [
                  {
                    hd: x,
                    tl: /* [] */0
                  },
                  prev
                ];
      
    }
  };
}

function set_idx(idx, param) {
  if (!param) {
    return /* [] */0;
  }
  var marks = param.hd;
  switch (marks.TAG | 0) {
    case /* TSeq */0 :
        return {
                hd: {
                  TAG: /* TSeq */0,
                  _0: set_idx(idx, marks._0),
                  _1: marks._1,
                  _2: marks._2
                },
                tl: set_idx(idx, param.tl)
              };
    case /* TExp */1 :
        return {
                hd: {
                  TAG: /* TExp */1,
                  _0: marks_set_idx$1(marks._0, idx),
                  _1: marks._1
                },
                tl: set_idx(idx, param.tl)
              };
    case /* TMatch */2 :
        return {
                hd: {
                  TAG: /* TMatch */2,
                  _0: marks_set_idx$1(marks._0, idx)
                },
                tl: set_idx(idx, param.tl)
              };
    
  }
}

function filter_marks(b, e, marks) {
  return {
          marks: List.filter(function (param) {
                  var i = param[0];
                  if (i < b) {
                    return true;
                  } else {
                    return i > e;
                  }
                })(marks.marks),
          pmarks: marks.pmarks
        };
}

function delta_1(marks, c, next_cat, prev_cat, x, rem) {
  var s = x.def;
  if (typeof s === "number") {
    return {
            hd: {
              TAG: /* TMatch */2,
              _0: marks
            },
            tl: rem
          };
  }
  switch (s.TAG | 0) {
    case /* Cst */0 :
        if (Cset.mem(c, s._0)) {
          return {
                  hd: {
                    TAG: /* TExp */1,
                    _0: marks,
                    _1: eps_expr
                  },
                  tl: rem
                };
        } else {
          return rem;
        }
    case /* Alt */1 :
        return delta_2(marks, c, next_cat, prev_cat, s._0, rem);
    case /* Seq */2 :
        var y$p = delta_1(marks, c, next_cat, prev_cat, s._1, /* [] */0);
        return delta_seq(c, next_cat, prev_cat, s._0, y$p, s._2, rem);
    case /* Rep */3 :
        var kind = s._1;
        var y$p$1 = delta_1(marks, c, next_cat, prev_cat, s._2, /* [] */0);
        var marks$p = first((function (marks) {
                switch (marks.TAG | 0) {
                  case /* TSeq */0 :
                  case /* TExp */1 :
                      return ;
                  case /* TMatch */2 :
                      return marks._0;
                  
                }
              }), y$p$1);
        var match = marks$p !== undefined ? [
            remove_matches(y$p$1),
            marks$p
          ] : [
            y$p$1,
            marks
          ];
        var y$p$p = match[0];
        if (s._0 === "Non_greedy") {
          return {
                  hd: {
                    TAG: /* TMatch */2,
                    _0: marks
                  },
                  tl: tseq(kind, y$p$p, x, rem)
                };
        } else {
          return tseq(kind, y$p$p, x, {
                      hd: {
                        TAG: /* TMatch */2,
                        _0: match[1]
                      },
                      tl: rem
                    });
        }
    case /* Mark */4 :
        var i = s._0;
        var marks_marks = {
          hd: [
            i,
            -1
          ],
          tl: List.remove_assq(i, marks.marks)
        };
        var marks_pmarks = marks.pmarks;
        var marks$1 = {
          marks: marks_marks,
          pmarks: marks_pmarks
        };
        return {
                hd: {
                  TAG: /* TMatch */2,
                  _0: marks$1
                },
                tl: rem
              };
    case /* Erase */5 :
        return {
                hd: {
                  TAG: /* TMatch */2,
                  _0: filter_marks(s._0, s._1, marks)
                },
                tl: rem
              };
    case /* Before */6 :
        if (Category.intersect(next_cat, s._0)) {
          return {
                  hd: {
                    TAG: /* TMatch */2,
                    _0: marks
                  },
                  tl: rem
                };
        } else {
          return rem;
        }
    case /* After */7 :
        if (Category.intersect(prev_cat, s._0)) {
          return {
                  hd: {
                    TAG: /* TMatch */2,
                    _0: marks
                  },
                  tl: rem
                };
        } else {
          return rem;
        }
    case /* Pmark */8 :
        var marks_marks$1 = marks.marks;
        var marks_pmarks$1 = Curry._2(Pmark.$$Set.add, s._0, marks.pmarks);
        var marks$2 = {
          marks: marks_marks$1,
          pmarks: marks_pmarks$1
        };
        return {
                hd: {
                  TAG: /* TMatch */2,
                  _0: marks$2
                },
                tl: rem
              };
    
  }
}

function delta_2(marks, c, next_cat, prev_cat, l, rem) {
  if (l) {
    return delta_1(marks, c, next_cat, prev_cat, l.hd, delta_2(marks, c, next_cat, prev_cat, l.tl, rem));
  } else {
    return rem;
  }
}

function delta_seq(c, next_cat, prev_cat, kind, y, z, rem) {
  var marks = first((function (marks) {
          switch (marks.TAG | 0) {
            case /* TSeq */0 :
            case /* TExp */1 :
                return ;
            case /* TMatch */2 :
                return marks._0;
            
          }
        }), y);
  if (marks === undefined) {
    return tseq(kind, y, z, rem);
  }
  if (kind === "Longest") {
    return tseq(kind, remove_matches(y), z, delta_1(marks, c, next_cat, prev_cat, z, rem));
  }
  if (kind !== "First") {
    return delta_1(marks, c, next_cat, prev_cat, z, tseq(kind, remove_matches(y), z, rem));
  }
  var match = split_at_match_rec(/* [] */0, y);
  return tseq(kind, match[0], z, delta_1(marks, c, next_cat, prev_cat, z, tseq(kind, match[1], z, rem)));
}

function delta_3(c, next_cat, prev_cat, x, rem) {
  switch (x.TAG | 0) {
    case /* TSeq */0 :
        var y$p = delta_4(c, next_cat, prev_cat, x._0, /* [] */0);
        return delta_seq(c, next_cat, prev_cat, x._2, y$p, x._1, rem);
    case /* TExp */1 :
        return delta_1(x._0, c, next_cat, prev_cat, x._1, rem);
    case /* TMatch */2 :
        return {
                hd: x,
                tl: rem
              };
    
  }
}

function delta_4(c, next_cat, prev_cat, l, rem) {
  if (l) {
    return delta_3(c, next_cat, prev_cat, l.hd, delta_4(c, next_cat, prev_cat, l.tl, rem));
  } else {
    return rem;
  }
}

function delta(tbl_ref, next_cat, $$char, st) {
  var prev_cat = st.category;
  var match = remove_duplicates(/* [] */0, delta_4($$char, next_cat, prev_cat, st.desc, /* [] */0), eps_expr);
  var expr$p = match[0];
  var idx = free_index(tbl_ref, expr$p);
  var expr$p$p = set_idx(idx, expr$p);
  return mk(idx, next_cat, expr$p$p);
}

function red_tr(_l) {
  while(true) {
    var l = _l;
    if (!l) {
      return l;
    }
    var match = l.tl;
    if (!match) {
      return l;
    }
    var rem = match.tl;
    var tr2 = match.hd;
    var tr1 = l.hd;
    var st1 = tr1[1];
    if (!equal$1(st1, tr2[1])) {
      return {
              hd: tr1,
              tl: red_tr({
                    hd: tr2,
                    tl: rem
                  })
            };
    }
    _l = {
      hd: [
        Cset.union(tr1[0], tr2[0]),
        st1
      ],
      tl: rem
    };
    continue ;
  };
}

function simpl_tr(l) {
  return List.sort((function (param, param$1) {
                return Caml_obj.caml_compare(param[0], param$1[0]);
              }), red_tr(List.sort((function (param, param$1) {
                        return compare(param[1], param$1[1]);
                      }), l)));
}

function prepend_deriv(param, param$1) {
  return List.fold_right((function (param, l) {
                return Cset.prepend(param[0], param[1], l);
              }), param, param$1);
}

function restrict(s, _param) {
  while(true) {
    var param = _param;
    if (!param) {
      return /* [] */0;
    }
    var rem = param.tl;
    var match = param.hd;
    var s$p$p = Cset.inter(s, match[0]);
    if (!Cset.is_empty(s$p$p)) {
      return {
              hd: [
                s$p$p,
                match[1]
              ],
              tl: restrict(s, rem)
            };
    }
    _param = rem;
    continue ;
  };
}

function remove_marks(b, _e, _rem) {
  while(true) {
    var rem = _rem;
    var e = _e;
    if (b > e) {
      return rem;
    }
    _rem = {
      hd: [
        e,
        -2
      ],
      tl: rem
    };
    _e = e - 1 | 0;
    continue ;
  };
}

function prepend_marks_expr(m, m$p) {
  switch (m$p.TAG | 0) {
    case /* TSeq */0 :
        return {
                TAG: /* TSeq */0,
                _0: List.map((function (param) {
                        return prepend_marks_expr(m, param);
                      }), m$p._0),
                _1: m$p._1,
                _2: m$p._2
              };
    case /* TExp */1 :
        return {
                TAG: /* TExp */1,
                _0: merge(m, m$p._0),
                _1: m$p._1
              };
    case /* TMatch */2 :
        return {
                TAG: /* TMatch */2,
                _0: merge(m, m$p._0)
              };
    
  }
}

function prepend_marks_expr_lst(m, l) {
  return List.map((function (param) {
                return prepend_marks_expr(m, param);
              }), l);
}

function prepend_marks(m) {
  return function (param) {
    return List.map((function (param) {
                  return [
                          param[0],
                          List.map((function (param) {
                                  return prepend_marks_expr(m, param);
                                }), param[1])
                        ];
                }), param);
  };
}

function deriv_1(all_chars, categories, marks, cat, x, rem) {
  var s = x.def;
  if (typeof s !== "number") {
    switch (s.TAG | 0) {
      case /* Cst */0 :
          return Cset.prepend(s._0, {
                      hd: {
                        TAG: /* TExp */1,
                        _0: marks,
                        _1: eps_expr
                      },
                      tl: /* [] */0
                    }, rem);
      case /* Alt */1 :
          return deriv_2(all_chars, categories, marks, cat, s._0, rem);
      case /* Seq */2 :
          var y$p = deriv_1(all_chars, categories, marks, cat, s._1, {
                hd: [
                  all_chars,
                  /* [] */0
                ],
                tl: /* [] */0
              });
          return deriv_seq(all_chars, categories, cat, s._0, y$p, s._2, rem);
      case /* Rep */3 :
          var kind = s._1;
          var rep_kind = s._0;
          var y$p$1 = deriv_1(all_chars, categories, marks, cat, s._2, {
                hd: [
                  all_chars,
                  /* [] */0
                ],
                tl: /* [] */0
              });
          return List.fold_right((function (param, rem) {
                        var z = param[1];
                        var marks$p = first((function (marks) {
                                switch (marks.TAG | 0) {
                                  case /* TSeq */0 :
                                  case /* TExp */1 :
                                      return ;
                                  case /* TMatch */2 :
                                      return marks._0;
                                  
                                }
                              }), z);
                        var match = marks$p !== undefined ? [
                            remove_matches(z),
                            marks$p
                          ] : [
                            z,
                            marks
                          ];
                        var z$p = match[0];
                        return Cset.prepend(param[0], rep_kind === "Non_greedy" ? ({
                                        hd: {
                                          TAG: /* TMatch */2,
                                          _0: marks
                                        },
                                        tl: tseq(kind, z$p, x, /* [] */0)
                                      }) : tseq(kind, z$p, x, {
                                          hd: {
                                            TAG: /* TMatch */2,
                                            _0: match[1]
                                          },
                                          tl: /* [] */0
                                        }), rem);
                      }), y$p$1, rem);
      case /* Mark */4 :
          var i = s._0;
          return Cset.prepend(all_chars, {
                      hd: {
                        TAG: /* TMatch */2,
                        _0: {
                          marks: {
                            hd: [
                              i,
                              -1
                            ],
                            tl: List.remove_assq(i, marks.marks)
                          },
                          pmarks: marks.pmarks
                        }
                      },
                      tl: /* [] */0
                    }, rem);
      case /* Erase */5 :
          var e = s._1;
          var b = s._0;
          return Cset.prepend(all_chars, {
                      hd: {
                        TAG: /* TMatch */2,
                        _0: {
                          marks: remove_marks(b, e, filter_marks(b, e, marks).marks),
                          pmarks: marks.pmarks
                        }
                      },
                      tl: /* [] */0
                    }, rem);
      case /* Before */6 :
          return Cset.prepend(List.assq(s._0, categories), {
                      hd: {
                        TAG: /* TMatch */2,
                        _0: marks
                      },
                      tl: /* [] */0
                    }, rem);
      case /* After */7 :
          if (Category.intersect(cat, s._0)) {
            return Cset.prepend(all_chars, {
                        hd: {
                          TAG: /* TMatch */2,
                          _0: marks
                        },
                        tl: /* [] */0
                      }, rem);
          } else {
            return rem;
          }
      case /* Pmark */8 :
          break;
      
    }
  }
  return Cset.prepend(all_chars, {
              hd: {
                TAG: /* TMatch */2,
                _0: marks
              },
              tl: /* [] */0
            }, rem);
}

function deriv_2(all_chars, categories, marks, cat, l, rem) {
  if (l) {
    return deriv_1(all_chars, categories, marks, cat, l.hd, deriv_2(all_chars, categories, marks, cat, l.tl, rem));
  } else {
    return rem;
  }
}

function deriv_seq(all_chars, categories, cat, kind, y, z, rem) {
  if (!List.exists((function (param) {
            return List.exists((function (param) {
                          switch (param.TAG | 0) {
                            case /* TSeq */0 :
                            case /* TExp */1 :
                                return false;
                            case /* TMatch */2 :
                                return true;
                            
                          }
                        }), param[1]);
          }), y)) {
    return List.fold_right((function (param, rem) {
                  return Cset.prepend(param[0], tseq(kind, param[1], z, /* [] */0), rem);
                }), y, rem);
  }
  var z$p = deriv_1(all_chars, categories, empty, cat, z, {
        hd: [
          all_chars,
          /* [] */0
        ],
        tl: /* [] */0
      });
  return List.fold_right((function (param, rem) {
                var y = param[1];
                var s = param[0];
                var marks = first((function (marks) {
                        switch (marks.TAG | 0) {
                          case /* TSeq */0 :
                          case /* TExp */1 :
                              return ;
                          case /* TMatch */2 :
                              return marks._0;
                          
                        }
                      }), y);
                if (marks === undefined) {
                  return Cset.prepend(s, tseq(kind, y, z, /* [] */0), rem);
                }
                var z$p$p = prepend_marks(marks)(z$p);
                if (kind === "Longest") {
                  return Cset.prepend(s, tseq(kind, remove_matches(y), z, /* [] */0), prepend_deriv(restrict(s, z$p$p), rem));
                }
                if (kind !== "First") {
                  return prepend_deriv(restrict(s, z$p$p), Cset.prepend(s, tseq(kind, remove_matches(y), z, /* [] */0), rem));
                }
                var match = split_at_match_rec(/* [] */0, y);
                return Cset.prepend(s, tseq(kind, match[0], z, /* [] */0), prepend_deriv(restrict(s, z$p$p), Cset.prepend(s, tseq(kind, match[1], z, /* [] */0), rem)));
              }), y, rem);
}

function deriv_3(all_chars, categories, cat, x, rem) {
  switch (x.TAG | 0) {
    case /* TSeq */0 :
        var y$p = deriv_4(all_chars, categories, cat, x._0, {
              hd: [
                all_chars,
                /* [] */0
              ],
              tl: /* [] */0
            });
        return deriv_seq(all_chars, categories, cat, x._2, y$p, x._1, rem);
    case /* TExp */1 :
        return deriv_1(all_chars, categories, x._0, cat, x._1, rem);
    case /* TMatch */2 :
        return Cset.prepend(all_chars, {
                    hd: x,
                    tl: /* [] */0
                  }, rem);
    
  }
}

function deriv_4(all_chars, categories, cat, l, rem) {
  if (l) {
    return deriv_3(all_chars, categories, cat, l.hd, deriv_4(all_chars, categories, cat, l.tl, rem));
  } else {
    return rem;
  }
}

function deriv(tbl_ref, all_chars, categories, st) {
  var der = deriv_4(all_chars, categories, st.category, st.desc, {
        hd: [
          all_chars,
          /* [] */0
        ],
        tl: /* [] */0
      });
  return simpl_tr(List.fold_right((function (param, rem) {
                    var s = param[0];
                    var match = remove_duplicates(/* [] */0, param[1], eps_expr);
                    var expr$p = match[0];
                    var idx = free_index(tbl_ref, expr$p);
                    var expr$p$p = set_idx(idx, expr$p);
                    return List.fold_right((function (param, rem) {
                                  var s$p$p = Cset.inter(s, param[1]);
                                  if (Cset.is_empty(s$p$p)) {
                                    return rem;
                                  } else {
                                    return {
                                            hd: [
                                              s$p$p,
                                              mk(idx, param[0], expr$p$p)
                                            ],
                                            tl: rem
                                          };
                                  }
                                }), categories, rem);
                  }), der, /* [] */0));
}

function flatten_match(m) {
  var ma = List.fold_left((function (ma, param) {
          return Caml.caml_int_max(ma, param[0]);
        }), -1, m);
  var res = Caml_array.make(ma + 1 | 0, -1);
  List.iter((function (param) {
          return Caml_array.set(res, param[0], param[1]);
        }), m);
  return res;
}

function status(s) {
  var st = s.status;
  if (st !== undefined) {
    return st;
  }
  var match = s.desc;
  var st$1;
  if (match) {
    var m = match.hd;
    switch (m.TAG | 0) {
      case /* TSeq */0 :
      case /* TExp */1 :
          st$1 = /* Running */1;
          break;
      case /* TMatch */2 :
          var m$1 = m._0;
          st$1 = /* Match */{
            _0: flatten_match(m$1.marks),
            _1: m$1.pmarks
          };
          break;
      
    }
  } else {
    st$1 = /* Failed */0;
  }
  s.status = st$1;
  return st$1;
}

export {
  hash_combine ,
  Marks ,
  pp_sem ,
  pp_rep_kind ,
  print_one ,
  pp ,
  first ,
  create_ids ,
  eps_expr ,
  mk_expr ,
  empty$1 as empty,
  cst ,
  alt ,
  seq ,
  is_eps ,
  eps ,
  rep ,
  mark ,
  pmark ,
  erase ,
  before ,
  after ,
  rename ,
  E ,
  State ,
  create_working_area ,
  index_count ,
  reset_table ,
  mark_used_indices ,
  find_free ,
  free_index ,
  remove_matches ,
  split_at_match_rec ,
  split_at_match ,
  remove_duplicates ,
  set_idx ,
  filter_marks ,
  delta_1 ,
  delta_2 ,
  delta_seq ,
  delta_3 ,
  delta_4 ,
  delta ,
  red_tr ,
  simpl_tr ,
  prepend_deriv ,
  restrict ,
  remove_marks ,
  prepend_marks_expr ,
  prepend_marks_expr_lst ,
  prepend_marks ,
  deriv_1 ,
  deriv_2 ,
  deriv_seq ,
  deriv_3 ,
  deriv_4 ,
  deriv ,
  flatten_match ,
  status ,
  
}
/* Table Not a pure module */
