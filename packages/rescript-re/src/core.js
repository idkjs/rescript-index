// Generated by Melange

import * as Fmt from "./fmt.js";
import * as Seq from "@rescript/std/lib/es6/seq.js";
import * as Char from "@rescript/std/lib/es6/char.js";
import * as Cset from "./cset.js";
import * as List from "@rescript/std/lib/es6/list.js";
import * as $$Array from "@rescript/std/lib/es6/array.js";
import * as Curry from "@rescript/std/lib/es6/curry.js";
import * as Group from "./group.js";
import * as Pmark from "./pmark.js";
import * as $$Buffer from "@rescript/std/lib/es6/buffer.js";
import * as Stdlib from "@rescript/std/lib/es6/stdlib.js";
import * as $$String from "@rescript/std/lib/es6/string.js";
import * as Automata from "./automata.js";
import * as Caml_obj from "@rescript/std/lib/es6/caml_obj.js";
import * as Category from "./category.js";
import * as Color_map from "./color_map.js";
import * as Caml_array from "@rescript/std/lib/es6/caml_array.js";
import * as Caml_bytes from "@rescript/std/lib/es6/caml_bytes.js";
import * as Caml_option from "@rescript/std/lib/es6/caml_option.js";
import * as Caml_string from "@rescript/std/lib/es6/caml_string.js";
import * as Caml_js_exceptions from "@rescript/std/lib/es6/caml_js_exceptions.js";

function iter(_n, f, _v) {
  while(true) {
    var v = _v;
    var n = _n;
    if (n === 0) {
      return v;
    }
    _v = Curry._1(f, v);
    _n = n - 1 | 0;
    continue ;
  };
}

function pp_re(ch, re) {
  return Automata.pp(ch, re.initial);
}

function category(re, color) {
  if (color === -1) {
    return Category.inexistant;
  } else if (color === re.lnl) {
    return Category.$caret(Category.$caret(Category.lastnewline, Category.newline), Category.not_letter);
  } else {
    return Category.from_char(Caml_bytes.get(re.color_repr, color));
  }
}

var dummy_next = [];

var unknown_state = {
  idx: -2,
  real_idx: 0,
  next: dummy_next,
  final: /* [] */0,
  desc: Automata.State.dummy
};

function mk_state(ncol, desc) {
  var match = Automata.status(desc);
  var break_state = typeof match === "number" && match ? false : true;
  return {
          idx: break_state ? -3 : desc.idx,
          real_idx: desc.idx,
          next: break_state ? dummy_next : Caml_array.make(ncol, unknown_state),
          final: /* [] */0,
          desc: desc
        };
}

function find_state(re, desc) {
  try {
    return Curry._2(Automata.State.Table.find, re.states, desc);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib.Not_found) {
      var st = mk_state(re.ncolor, desc);
      Curry._3(Automata.State.Table.add, re.states, desc, st);
      return st;
    }
    throw exn;
  }
}

function delta(info, cat, color, st) {
  var desc = Automata.delta(info.re.tbl, cat, color, st.desc);
  var len = info.positions.length;
  if (desc.idx === len && len > 0) {
    var pos = info.positions;
    info.positions = Caml_array.make((len << 1), 0);
    $$Array.blit(pos, 0, info.positions, 0, len);
  }
  return desc;
}

function validate(info, s, pos, st) {
  var color = Caml_bytes.get(info.colors, Caml_string.get(s, pos));
  var cat = category(info.re, color);
  var desc$p = delta(info, cat, color, st);
  var st$p = find_state(info.re, desc$p);
  return Caml_array.set(st.next, color, st$p);
}

function loop(info, s, pos, st) {
  if (pos >= info.last) {
    return st;
  }
  var st$p = Caml_array.get(st.next, Caml_bytes.get(info.colors, Caml_string.get(s, pos)));
  var _pos = pos;
  var _st = st;
  var _st$p = st$p;
  while(true) {
    var st$p$1 = _st$p;
    var st$1 = _st;
    var pos$1 = _pos;
    if (st$p$1.idx < 0) {
      if (st$p$1.idx === -3) {
        Caml_array.set(info.positions, st$p$1.real_idx, pos$1 + 1 | 0);
        return st$p$1;
      } else {
        validate(info, s, pos$1, st$1);
        return loop(info, s, pos$1, st$1);
      }
    }
    var pos$2 = pos$1 + 1 | 0;
    if (pos$2 < info.last) {
      var st$p$p = Caml_array.get(st$p$1.next, Caml_bytes.get(info.colors, Caml_string.get(s, pos$2)));
      Caml_array.set(info.positions, st$p$1.idx, pos$2);
      _st$p = st$p$p;
      _st = st$p$1;
      _pos = pos$2;
      continue ;
    }
    Caml_array.set(info.positions, st$p$1.idx, pos$2);
    return st$p$1;
  };
}

function $$final(info, st, cat) {
  try {
    return List.assq(cat, st.final);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib.Not_found) {
      var st$p = delta(info, cat, -1, st);
      var res_0 = st$p.idx;
      var res_1 = Automata.status(st$p);
      var res = [
        res_0,
        res_1
      ];
      st.final = {
        hd: [
          cat,
          res
        ],
        tl: st.final
      };
      return res;
    }
    throw exn;
  }
}

function find_initial_state(re, cat) {
  try {
    return List.assq(cat, re.initial_states);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib.Not_found) {
      var st = find_state(re, Automata.State.create(cat, re.initial));
      re.initial_states = {
        hd: [
          cat,
          st
        ],
        tl: re.initial_states
      };
      return st;
    }
    throw exn;
  }
}

function get_color(re, s, pos) {
  if (pos < 0) {
    return -1;
  }
  var slen = s.length;
  if (pos >= slen) {
    return -1;
  } else if (pos === (slen - 1 | 0) && re.lnl !== -1 && Caml_string.get(s, pos) === /* '\n' */10) {
    return re.lnl;
  } else {
    return Caml_bytes.get(re.colors, Caml_string.get(s, pos));
  }
}

function scan_str(info, s, initial_state, groups) {
  var pos = info.pos;
  var last = info.last;
  if (!(last === s.length && info.re.lnl !== -1 && last > pos && Caml_string.get(s, last - 1 | 0) === /* '\n' */10)) {
    if (groups) {
      return loop(info, s, pos, initial_state);
    } else {
      var _pos = pos;
      var _st = initial_state;
      while(true) {
        var st = _st;
        var pos$1 = _pos;
        if (pos$1 >= last) {
          return st;
        }
        var st$p = Caml_array.get(st.next, Caml_bytes.get(info.colors, Caml_string.get(s, pos$1)));
        if (st$p.idx >= 0) {
          _st = st$p;
          _pos = pos$1 + 1 | 0;
          continue ;
        }
        if (st$p.idx === -3) {
          return st$p;
        }
        validate(info, s, pos$1, st);
        continue ;
      };
    }
  }
  var info$1 = {
    re: info.re,
    colors: info.colors,
    positions: info.positions,
    pos: info.pos,
    last: last - 1 | 0
  };
  var st$1 = scan_str(info$1, s, initial_state, groups);
  if (st$1.idx === -3) {
    return st$1;
  } else {
    var pos$2 = last - 1 | 0;
    while(true) {
      var st$p$1 = Caml_array.get(st$1.next, info$1.re.lnl);
      if (st$p$1.idx >= 0) {
        if (groups) {
          Caml_array.set(info$1.positions, st$p$1.idx, pos$2 + 1 | 0);
        }
        return st$p$1;
      }
      if (st$p$1.idx === -3) {
        if (groups) {
          Caml_array.set(info$1.positions, st$p$1.real_idx, pos$2 + 1 | 0);
        }
        return st$p$1;
      }
      var color = info$1.re.lnl;
      var real_c = Caml_bytes.get(info$1.colors, /* '\n' */10);
      var cat = category(info$1.re, color);
      var desc$p = delta(info$1, cat, real_c, st$1);
      var st$p$2 = find_state(info$1.re, desc$p);
      Caml_array.set(st$1.next, color, st$p$2);
      continue ;
    };
  }
}

function match_str(groups, partial, re, s, pos, len) {
  var slen = s.length;
  var last = len === -1 ? slen : pos + len | 0;
  var tmp;
  if (groups) {
    var n = Automata.index_count(re.tbl) + 1 | 0;
    tmp = n <= 10 ? [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ] : Caml_array.make(n, 0);
  } else {
    tmp = [];
  }
  var info = {
    re: re,
    colors: re.colors,
    positions: tmp,
    pos: pos,
    last: last
  };
  var initial_cat = pos === 0 ? Category.$caret(Category.search_boundary, Category.inexistant) : Category.$caret(Category.search_boundary, category(re, get_color(re, s, pos - 1 | 0)));
  var initial_state = find_initial_state(re, initial_cat);
  var st = scan_str(info, s, initial_state, groups);
  var res;
  if (st.idx === -3 || partial) {
    res = Automata.status(st.desc);
  } else {
    var final_cat = last === slen ? Category.$caret(Category.search_boundary, Category.inexistant) : Category.$caret(Category.search_boundary, category(re, get_color(re, s, last)));
    var match = $$final(info, st, final_cat);
    if (groups) {
      Caml_array.set(info.positions, match[0], last + 1 | 0);
    }
    res = match[1];
  }
  if (typeof res === "number") {
    if (res) {
      return /* Running */1;
    } else {
      return /* Failed */0;
    }
  } else {
    return /* Match */{
            _0: {
              s: s,
              marks: res._0,
              pmarks: res._1,
              gpos: info.positions,
              gcount: re.group_count
            }
          };
  }
}

var cadd = Cset.add;

function trans_set(cache, cm, s) {
  var i = Cset.one_char(s);
  if (i !== undefined) {
    return Cset.csingle(Caml_bytes.get(cm, i));
  }
  var v_0 = Cset.hash_rec(s);
  var v = [
    v_0,
    s
  ];
  try {
    return Curry._2(Cset.CSetMap.find, v, cache.contents);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib.Not_found) {
      var l = Cset.fold_right(s, Cset.empty, (function (param, l) {
              return Cset.union(Cset.seq(Caml_bytes.get(cm, param[0]), Caml_bytes.get(cm, param[1])), l);
            }));
      cache.contents = Curry._3(Cset.CSetMap.add, v, l, cache.contents);
      return l;
    }
    throw exn;
  }
}

function view(t) {
  return t;
}

var View = {
  view: view
};

function pp(fmt, t) {
  var $$var = function (s, re) {
    return Fmt.sexp(fmt, s, pp, re);
  };
  var seq = function (s, rel) {
    return Fmt.sexp(fmt, s, (function (param, param$1) {
                  return Fmt.list(undefined, pp, param, param$1);
                }), rel);
  };
  if (typeof t === "number") {
    switch (t) {
      case /* Beg_of_line */0 :
          return Fmt.str(fmt, "Beg_of_line");
      case /* End_of_line */1 :
          return Fmt.str(fmt, "End_of_line");
      case /* Beg_of_word */2 :
          return Fmt.str(fmt, "Beg_of_word");
      case /* End_of_word */3 :
          return Fmt.str(fmt, "End_of_word");
      case /* Not_bound */4 :
          return Fmt.str(fmt, "Not_bound");
      case /* Beg_of_str */5 :
          return Fmt.str(fmt, "Beg_of_str");
      case /* End_of_str */6 :
          return Fmt.str(fmt, "End_of_str");
      case /* Last_end_of_line */7 :
          return Fmt.str(fmt, "Last_end_of_line");
      case /* Start */8 :
          return Fmt.str(fmt, "Start");
      case /* Stop */9 :
          return Fmt.str(fmt, "Stop");
      
    }
  } else {
    switch (t.TAG | 0) {
      case /* Set */0 :
          return Fmt.sexp(fmt, "Set", Cset.pp, t._0);
      case /* Sequence */1 :
          return seq("Sequence", t._0);
      case /* Alternative */2 :
          return seq("Alternative", t._0);
      case /* Repeat */3 :
          var stop = t._2;
          var start = t._1;
          var re = t._0;
          var pp$p = function (fmt, param) {
            return Curry._5(Fmt.fprintf(fmt)(/* Format */{
                            _0: {
                              TAG: /* Alpha */15,
                              _0: {
                                TAG: /* Formatting_lit */17,
                                _0: {
                                  TAG: /* Break */0,
                                  _0: "@ ",
                                  _1: 1,
                                  _2: 0
                                },
                                _1: {
                                  TAG: /* Int */4,
                                  _0: /* Int_d */0,
                                  _1: /* No_padding */0,
                                  _2: /* No_precision */0,
                                  _3: {
                                    TAG: /* Alpha */15,
                                    _0: /* End_of_format */0
                                  }
                                }
                              }
                            },
                            _1: "%a@ %d%a"
                          }), pp, re, start, Fmt.optint, stop);
          };
          return Fmt.sexp(fmt, "Repeat", pp$p, undefined);
      case /* Sem */4 :
          return Fmt.sexp(fmt, "Sem", (function (param, param$1) {
                        return Fmt.pair(Automata.pp_sem, pp, param, param$1);
                      }), [
                      t._0,
                      t._1
                    ]);
      case /* Sem_greedy */5 :
          return Fmt.sexp(fmt, "Sem_greedy", (function (param, param$1) {
                        return Fmt.pair(Automata.pp_rep_kind, pp, param, param$1);
                      }), [
                      t._0,
                      t._1
                    ]);
      case /* Group */6 :
          return $$var("Group", t._0);
      case /* No_group */7 :
          return $$var("No_group", t._0);
      case /* Nest */8 :
          return $$var("Nest", t._0);
      case /* Case */9 :
          return $$var("Case", t._0);
      case /* No_case */10 :
          return $$var("No_case", t._0);
      case /* Intersection */11 :
          return seq("Intersection", t._0);
      case /* Complement */12 :
          return seq("Complement", t._0);
      case /* Difference */13 :
          return Fmt.sexp(fmt, "Difference", (function (param, param$1) {
                        return Fmt.pair(pp, pp, param, param$1);
                      }), [
                      t._0,
                      t._1
                    ]);
      case /* Pmark */14 :
          return Fmt.sexp(fmt, "Pmark", (function (param, param$1) {
                        return Fmt.pair(Pmark.pp, pp, param, param$1);
                      }), [
                      t._0,
                      t._1
                    ]);
      
    }
  }
}

function is_charset(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return false;
    }
    switch (param.TAG | 0) {
      case /* Set */0 :
          return true;
      case /* Sem */4 :
      case /* Sem_greedy */5 :
          _param = param._1;
          continue ;
      case /* No_group */7 :
      case /* Case */9 :
      case /* No_case */10 :
          _param = param._0;
          continue ;
      case /* Alternative */2 :
      case /* Intersection */11 :
      case /* Complement */12 :
          return List.for_all(is_charset, param._0);
      case /* Difference */13 :
          if (!is_charset(param._0)) {
            return false;
          }
          _param = param._1;
          continue ;
      default:
        return false;
    }
  };
}

var cupper = Cset.union(Cset.seq(/* 'A' */65, /* 'Z' */90), Cset.union(Cset.seq(/* '\192' */192, /* '\214' */214), Cset.seq(/* '\216' */216, /* '\222' */222)));

var clower = Cset.offset(32, cupper);

var calpha = List.fold_right(cadd, {
      hd: /* '\170' */170,
      tl: {
        hd: /* '\181' */181,
        tl: {
          hd: /* '\186' */186,
          tl: {
            hd: /* '\223' */223,
            tl: {
              hd: /* '\255' */255,
              tl: /* [] */0
            }
          }
        }
      }
    }, Cset.union(clower, cupper));

var cdigit = Cset.seq(/* '0' */48, /* '9' */57);

var calnum = Cset.union(calpha, cdigit);

var cword = Cset.add(/* '_' */95, calnum);

function colorize(c, regexp) {
  var lnl = {
    contents: false
  };
  var colorize$1 = function (_regexp) {
    while(true) {
      var regexp = _regexp;
      if (typeof regexp === "number") {
        switch (regexp) {
          case /* Beg_of_line */0 :
          case /* End_of_line */1 :
              return Color_map.split(Cset.csingle(/* '\n' */10), c);
          case /* Beg_of_word */2 :
          case /* End_of_word */3 :
          case /* Not_bound */4 :
              return Color_map.split(cword, c);
          case /* Last_end_of_line */7 :
              lnl.contents = true;
              return ;
          case /* Beg_of_str */5 :
          case /* End_of_str */6 :
          case /* Start */8 :
          case /* Stop */9 :
              return ;
          
        }
      } else {
        switch (regexp.TAG | 0) {
          case /* Set */0 :
              return Color_map.split(regexp._0, c);
          case /* Sequence */1 :
          case /* Alternative */2 :
              return List.iter(colorize$1, regexp._0);
          case /* Repeat */3 :
          case /* Group */6 :
          case /* No_group */7 :
          case /* Nest */8 :
              _regexp = regexp._0;
              continue ;
          case /* Sem */4 :
          case /* Sem_greedy */5 :
          case /* Pmark */14 :
              _regexp = regexp._1;
              continue ;
          default:
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "core.re",
                    604,
                    23
                  ],
                  Error: new Error()
                };
        }
      }
    };
  };
  colorize$1(regexp);
  return lnl.contents;
}

function equal(_x1, _x2) {
  while(true) {
    var x2 = _x2;
    var x1 = _x1;
    if (typeof x1 === "number") {
      switch (x1) {
        case /* Beg_of_line */0 :
            if (typeof x2 === "number" && !x2) {
              return true;
            } else {
              return false;
            }
        case /* End_of_line */1 :
            return x2 === 1;
        case /* Beg_of_word */2 :
            return x2 === 2;
        case /* End_of_word */3 :
            return x2 === 3;
        case /* Not_bound */4 :
            return x2 === 4;
        case /* Beg_of_str */5 :
            return x2 === 5;
        case /* End_of_str */6 :
            return x2 === 6;
        case /* Last_end_of_line */7 :
            return x2 === 7;
        case /* Start */8 :
            return x2 === 8;
        case /* Stop */9 :
            if (typeof x2 === "number") {
              return x2 >= 9;
            } else {
              return false;
            }
        
      }
    } else {
      switch (x1.TAG | 0) {
        case /* Set */0 :
            if (typeof x2 === "number" || x2.TAG !== /* Set */0) {
              return false;
            } else {
              return Caml_obj.caml_equal(x1._0, x2._0);
            }
        case /* Sequence */1 :
            if (typeof x2 === "number" || x2.TAG !== /* Sequence */1) {
              return false;
            } else {
              return eq_list(x1._0, x2._0);
            }
        case /* Alternative */2 :
            if (typeof x2 === "number" || x2.TAG !== /* Alternative */2) {
              return false;
            } else {
              return eq_list(x1._0, x2._0);
            }
        case /* Repeat */3 :
            if (typeof x2 === "number") {
              return false;
            }
            if (x2.TAG !== /* Repeat */3) {
              return false;
            }
            if (x1._1 !== x2._1) {
              return false;
            }
            if (!Caml_obj.caml_equal(x1._2, x2._2)) {
              return false;
            }
            _x2 = x2._0;
            _x1 = x1._0;
            continue ;
        case /* Sem */4 :
            if (typeof x2 === "number") {
              return false;
            }
            if (x2.TAG !== /* Sem */4) {
              return false;
            }
            if (x1._0 !== x2._0) {
              return false;
            }
            _x2 = x2._1;
            _x1 = x1._1;
            continue ;
        case /* Sem_greedy */5 :
            if (typeof x2 === "number") {
              return false;
            }
            if (x2.TAG !== /* Sem_greedy */5) {
              return false;
            }
            if (x1._0 !== x2._0) {
              return false;
            }
            _x2 = x2._1;
            _x1 = x1._1;
            continue ;
        case /* Group */6 :
            return false;
        case /* No_group */7 :
            if (typeof x2 === "number") {
              return false;
            }
            if (x2.TAG !== /* No_group */7) {
              return false;
            }
            _x2 = x2._0;
            _x1 = x1._0;
            continue ;
        case /* Nest */8 :
            if (typeof x2 === "number") {
              return false;
            }
            if (x2.TAG !== /* Nest */8) {
              return false;
            }
            _x2 = x2._0;
            _x1 = x1._0;
            continue ;
        case /* Case */9 :
            if (typeof x2 === "number") {
              return false;
            }
            if (x2.TAG !== /* Case */9) {
              return false;
            }
            _x2 = x2._0;
            _x1 = x1._0;
            continue ;
        case /* No_case */10 :
            if (typeof x2 === "number") {
              return false;
            }
            if (x2.TAG !== /* No_case */10) {
              return false;
            }
            _x2 = x2._0;
            _x1 = x1._0;
            continue ;
        case /* Intersection */11 :
            if (typeof x2 === "number" || x2.TAG !== /* Intersection */11) {
              return false;
            } else {
              return eq_list(x1._0, x2._0);
            }
        case /* Complement */12 :
            if (typeof x2 === "number" || x2.TAG !== /* Complement */12) {
              return false;
            } else {
              return eq_list(x1._0, x2._0);
            }
        case /* Difference */13 :
            if (typeof x2 === "number") {
              return false;
            }
            if (x2.TAG !== /* Difference */13) {
              return false;
            }
            if (!equal(x1._0, x2._0)) {
              return false;
            }
            _x2 = x2._1;
            _x1 = x1._1;
            continue ;
        case /* Pmark */14 :
            if (typeof x2 === "number") {
              return false;
            }
            if (x2.TAG !== /* Pmark */14) {
              return false;
            }
            if (!Pmark.equal(x1._0, x2._0)) {
              return false;
            }
            _x2 = x2._1;
            _x1 = x1._1;
            continue ;
        
      }
    }
  };
}

function eq_list(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (!l1) {
      if (l2) {
        return false;
      } else {
        return true;
      }
    }
    if (!l2) {
      return false;
    }
    if (!equal(l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue ;
  };
}

function sequence(l) {
  if (l && !l.tl) {
    return l.hd;
  } else {
    return {
            TAG: /* Sequence */1,
            _0: l
          };
  }
}

function merge_sequences(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return /* [] */0;
    }
    var l$p = param.hd;
    if (typeof l$p !== "number") {
      switch (l$p.TAG | 0) {
        case /* Sequence */1 :
            var match = l$p._0;
            if (match) {
              var y = match.tl;
              var x = match.hd;
              var r$p = merge_sequences(param.tl);
              var exit = 0;
              if (r$p) {
                var match$1 = r$p.hd;
                if (typeof match$1 === "number" || match$1.TAG !== /* Sequence */1) {
                  exit = 2;
                } else {
                  var match$2 = match$1._0;
                  if (match$2) {
                    if (equal(x, match$2.hd)) {
                      return {
                              hd: {
                                TAG: /* Sequence */1,
                                _0: {
                                  hd: x,
                                  tl: {
                                    hd: {
                                      TAG: /* Alternative */2,
                                      _0: {
                                        hd: sequence(y),
                                        tl: {
                                          hd: sequence(match$2.tl),
                                          tl: /* [] */0
                                        }
                                      }
                                    },
                                    tl: /* [] */0
                                  }
                                }
                              },
                              tl: r$p.tl
                            };
                    }
                    exit = 2;
                  } else {
                    exit = 2;
                  }
                }
              } else {
                exit = 2;
              }
              if (exit === 2) {
                return {
                        hd: {
                          TAG: /* Sequence */1,
                          _0: {
                            hd: x,
                            tl: y
                          }
                        },
                        tl: r$p
                      };
              }
              
            }
            break;
        case /* Alternative */2 :
            _param = Stdlib.$at(l$p._0, param.tl);
            continue ;
        default:
          
      }
    }
    return {
            hd: l$p,
            tl: merge_sequences(param.tl)
          };
  };
}

function enforce_kind(ids, kind, kind$p, cr) {
  if (kind === "First" && kind$p !== "First") {
    return Automata.seq(ids, kind$p, cr, Automata.eps(ids));
  } else {
    return cr;
  }
}

function translate(ids, kind, _ign_group, ign_case, _greedy, pos, cache, c, _s) {
  while(true) {
    var s = _s;
    var greedy = _greedy;
    var ign_group = _ign_group;
    if (typeof s === "number") {
      switch (s) {
        case /* Beg_of_line */0 :
            return [
                    Automata.after(ids, Category.$caret(Category.inexistant, Category.newline)),
                    kind
                  ];
        case /* End_of_line */1 :
            return [
                    Automata.before(ids, Category.$caret(Category.inexistant, Category.newline)),
                    kind
                  ];
        case /* Beg_of_word */2 :
            return [
                    Automata.seq(ids, "First", Automata.after(ids, Category.$caret(Category.inexistant, Category.not_letter)), Automata.before(ids, Category.$caret(Category.inexistant, Category.letter))),
                    kind
                  ];
        case /* End_of_word */3 :
            return [
                    Automata.seq(ids, "First", Automata.after(ids, Category.$caret(Category.inexistant, Category.letter)), Automata.before(ids, Category.$caret(Category.inexistant, Category.not_letter))),
                    kind
                  ];
        case /* Not_bound */4 :
            return [
                    Automata.alt(ids, {
                          hd: Automata.seq(ids, "First", Automata.after(ids, Category.letter), Automata.before(ids, Category.letter)),
                          tl: {
                            hd: Automata.seq(ids, "First", Automata.after(ids, Category.letter), Automata.before(ids, Category.letter)),
                            tl: /* [] */0
                          }
                        }),
                    kind
                  ];
        case /* Beg_of_str */5 :
            return [
                    Automata.after(ids, Category.inexistant),
                    kind
                  ];
        case /* End_of_str */6 :
            return [
                    Automata.before(ids, Category.inexistant),
                    kind
                  ];
        case /* Last_end_of_line */7 :
            return [
                    Automata.before(ids, Category.$caret(Category.inexistant, Category.lastnewline)),
                    kind
                  ];
        case /* Start */8 :
            return [
                    Automata.after(ids, Category.search_boundary),
                    kind
                  ];
        case /* Stop */9 :
            return [
                    Automata.before(ids, Category.search_boundary),
                    kind
                  ];
        
      }
    } else {
      switch (s.TAG | 0) {
        case /* Set */0 :
            return [
                    Automata.cst(ids, trans_set(cache, c, s._0)),
                    kind
                  ];
        case /* Sequence */1 :
            return [
                    trans_seq(ids, kind, ign_group, ign_case, greedy, pos, cache, c, s._0),
                    kind
                  ];
        case /* Alternative */2 :
            var merged_sequences = merge_sequences(s._0);
            if (merged_sequences && !merged_sequences.tl) {
              var match = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, merged_sequences.hd);
              return [
                      enforce_kind(ids, kind, match[1], match[0]),
                      kind
                    ];
            }
            return [
                    Automata.alt(ids, List.map((function(ign_group,greedy){
                            return function (r$p) {
                              var match = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, r$p);
                              return enforce_kind(ids, kind, match[1], match[0]);
                            }
                            }(ign_group,greedy)), merged_sequences)),
                    kind
                  ];
        case /* Repeat */3 :
            var j = s._2;
            var i = s._1;
            var match$1 = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, s._0);
            var kind$p = match$1[1];
            var cr = match$1[0];
            var rem;
            if (j !== undefined) {
              var f = greedy === "Non_greedy" ? (function(cr,kind$p){
                return function (rem) {
                  return Automata.alt(ids, {
                              hd: Automata.eps(ids),
                              tl: {
                                hd: Automata.seq(ids, kind$p, Automata.rename(ids, cr), rem),
                                tl: /* [] */0
                              }
                            });
                }
                }(cr,kind$p)) : (function(cr,kind$p){
                return function (rem) {
                  return Automata.alt(ids, {
                              hd: Automata.seq(ids, kind$p, Automata.rename(ids, cr), rem),
                              tl: {
                                hd: Automata.eps(ids),
                                tl: /* [] */0
                              }
                            });
                }
                }(cr,kind$p));
              rem = iter(j - i | 0, f, Automata.eps(ids));
            } else {
              rem = Automata.rep(ids, greedy, kind$p, cr);
            }
            return [
                    iter(i, (function(cr,kind$p){
                        return function (rem) {
                          return Automata.seq(ids, kind$p, Automata.rename(ids, cr), rem);
                        }
                        }(cr,kind$p)), rem),
                    kind
                  ];
        case /* Sem */4 :
            var kind$p$1 = s._0;
            var match$2 = translate(ids, kind$p$1, ign_group, ign_case, greedy, pos, cache, c, s._1);
            return [
                    enforce_kind(ids, kind$p$1, match$2[1], match$2[0]),
                    kind$p$1
                  ];
        case /* Sem_greedy */5 :
            _s = s._1;
            _greedy = s._0;
            continue ;
        case /* Group */6 :
            var r$p = s._0;
            if (ign_group) {
              _s = r$p;
              continue ;
            }
            var p = pos.contents;
            pos.contents = pos.contents + 2 | 0;
            var match$3 = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, r$p);
            return [
                    Automata.seq(ids, "First", Automata.mark(ids, p), Automata.seq(ids, "First", match$3[0], Automata.mark(ids, p + 1 | 0))),
                    match$3[1]
                  ];
        case /* No_group */7 :
            _s = s._0;
            _ign_group = true;
            continue ;
        case /* Nest */8 :
            var b = pos.contents;
            var match$4 = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, s._0);
            var kind$p$2 = match$4[1];
            var cr$1 = match$4[0];
            var e = pos.contents - 1 | 0;
            if (e < b) {
              return [
                      cr$1,
                      kind$p$2
                    ];
            } else {
              return [
                      Automata.seq(ids, "First", Automata.erase(ids, b, e), cr$1),
                      kind$p$2
                    ];
            }
        case /* Pmark */14 :
            var match$5 = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, s._1);
            return [
                    Automata.seq(ids, "First", Automata.pmark(ids, s._0), match$5[0]),
                    match$5[1]
                  ];
        default:
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "core.re",
                  863,
                  15
                ],
                Error: new Error()
              };
      }
    }
  };
}

function trans_seq(ids, kind, ign_group, ign_case, greedy, pos, cache, c, param) {
  if (!param) {
    return Automata.eps(ids);
  }
  var r = param.hd;
  if (param.tl) {
    var match = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, r);
    var cr$p = match[0];
    var cr$p$p = trans_seq(ids, kind, ign_group, ign_case, greedy, pos, cache, c, param.tl);
    if (Automata.is_eps(cr$p$p)) {
      return cr$p;
    } else if (Automata.is_eps(cr$p)) {
      return cr$p$p;
    } else {
      return Automata.seq(ids, match[1], cr$p, cr$p$p);
    }
  }
  var match$1 = translate(ids, kind, ign_group, ign_case, greedy, pos, cache, c, r);
  return enforce_kind(ids, kind, match$1[1], match$1[0]);
}

function case_insens(s) {
  return Cset.union(s, Cset.union(Cset.offset(32, Cset.inter(s, cupper)), Cset.offset(-32, Cset.inter(s, clower))));
}

function as_set(s) {
  if (typeof s === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "core.re",
            906,
            9
          ],
          Error: new Error()
        };
  }
  if (s.TAG === /* Set */0) {
    return s._0;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "core.re",
          906,
          9
        ],
        Error: new Error()
      };
}

function handle_case(_ign_case, _s) {
  while(true) {
    var s = _s;
    var ign_case = _ign_case;
    if (typeof s === "number") {
      return s;
    }
    switch (s.TAG | 0) {
      case /* Set */0 :
          var s$1 = s._0;
          return {
                  TAG: /* Set */0,
                  _0: ign_case ? case_insens(s$1) : s$1
                };
      case /* Sequence */1 :
          return {
                  TAG: /* Sequence */1,
                  _0: List.map((function(ign_case){
                      return function (param) {
                        return handle_case(ign_case, param);
                      }
                      }(ign_case)), s._0)
                };
      case /* Alternative */2 :
          var l$p = List.map((function(ign_case){
              return function (param) {
                return handle_case(ign_case, param);
              }
              }(ign_case)), s._0);
          if (is_charset({
                  TAG: /* Alternative */2,
                  _0: l$p
                })) {
            return {
                    TAG: /* Set */0,
                    _0: List.fold_left((function (s, r) {
                            return Cset.union(s, as_set(r));
                          }), Cset.empty, l$p)
                  };
          } else {
            return {
                    TAG: /* Alternative */2,
                    _0: l$p
                  };
          }
      case /* Repeat */3 :
          return {
                  TAG: /* Repeat */3,
                  _0: handle_case(ign_case, s._0),
                  _1: s._1,
                  _2: s._2
                };
      case /* Sem */4 :
          var r$p = handle_case(ign_case, s._1);
          if (is_charset(r$p)) {
            return r$p;
          } else {
            return {
                    TAG: /* Sem */4,
                    _0: s._0,
                    _1: r$p
                  };
          }
      case /* Sem_greedy */5 :
          var r$p$1 = handle_case(ign_case, s._1);
          if (is_charset(r$p$1)) {
            return r$p$1;
          } else {
            return {
                    TAG: /* Sem_greedy */5,
                    _0: s._0,
                    _1: r$p$1
                  };
          }
      case /* Group */6 :
          return {
                  TAG: /* Group */6,
                  _0: handle_case(ign_case, s._0)
                };
      case /* No_group */7 :
          var r$p$2 = handle_case(ign_case, s._0);
          if (is_charset(r$p$2)) {
            return r$p$2;
          } else {
            return {
                    TAG: /* No_group */7,
                    _0: r$p$2
                  };
          }
      case /* Nest */8 :
          var r$p$3 = handle_case(ign_case, s._0);
          if (is_charset(r$p$3)) {
            return r$p$3;
          } else {
            return {
                    TAG: /* Nest */8,
                    _0: r$p$3
                  };
          }
      case /* Case */9 :
          _s = s._0;
          _ign_case = false;
          continue ;
      case /* No_case */10 :
          _s = s._0;
          _ign_case = true;
          continue ;
      case /* Intersection */11 :
          var l$p$1 = List.map((function(ign_case){
              return function (r) {
                return handle_case(ign_case, r);
              }
              }(ign_case)), s._0);
          return {
                  TAG: /* Set */0,
                  _0: List.fold_left((function (s, r) {
                          return Cset.inter(s, as_set(r));
                        }), Cset.cany, l$p$1)
                };
      case /* Complement */12 :
          var l$p$2 = List.map((function(ign_case){
              return function (r) {
                return handle_case(ign_case, r);
              }
              }(ign_case)), s._0);
          return {
                  TAG: /* Set */0,
                  _0: Cset.diff(Cset.cany, List.fold_left((function (s, r) {
                              return Cset.union(s, as_set(r));
                            }), Cset.empty, l$p$2))
                };
      case /* Difference */13 :
          return {
                  TAG: /* Set */0,
                  _0: Cset.inter(as_set(handle_case(ign_case, s._0)), Cset.diff(Cset.cany, as_set(handle_case(ign_case, s._1))))
                };
      case /* Pmark */14 :
          return {
                  TAG: /* Pmark */14,
                  _0: s._0,
                  _1: handle_case(ign_case, s._1)
                };
      
    }
  };
}

function anchored(_l) {
  while(true) {
    var l = _l;
    if (typeof l === "number") {
      switch (l) {
        case /* Beg_of_str */5 :
        case /* Start */8 :
            return true;
        default:
          return false;
      }
    } else {
      switch (l.TAG | 0) {
        case /* Sequence */1 :
            return List.exists(anchored, l._0);
        case /* Alternative */2 :
            return List.for_all(anchored, l._0);
        case /* Repeat */3 :
            if (l._1 <= 0) {
              return false;
            }
            _l = l._0;
            continue ;
        case /* Group */6 :
        case /* No_group */7 :
        case /* Nest */8 :
        case /* Case */9 :
        case /* No_case */10 :
            _l = l._0;
            continue ;
        case /* Sem */4 :
        case /* Sem_greedy */5 :
        case /* Pmark */14 :
            _l = l._1;
            continue ;
        default:
          return false;
      }
    }
  };
}

function str(s) {
  var l = /* [] */0;
  for(var i = s.length - 1 | 0; i >= 0; --i){
    l = {
      hd: {
        TAG: /* Set */0,
        _0: Cset.csingle(Caml_string.get(s, i))
      },
      tl: l
    };
  }
  return {
          TAG: /* Sequence */1,
          _0: l
        };
}

function $$char(c) {
  return {
          TAG: /* Set */0,
          _0: Cset.csingle(c)
        };
}

function alt(l) {
  if (l && !l.tl) {
    return l.hd;
  } else {
    return {
            TAG: /* Alternative */2,
            _0: l
          };
  }
}

function seq(l) {
  if (l && !l.tl) {
    return l.hd;
  } else {
    return {
            TAG: /* Sequence */1,
            _0: l
          };
  }
}

var empty = {
  TAG: /* Alternative */2,
  _0: /* [] */0
};

var epsilon = {
  TAG: /* Sequence */1,
  _0: /* [] */0
};

function repn(r, i, j) {
  if (i < 0) {
    Stdlib.invalid_arg("Re.repn");
  }
  if (j !== undefined && Caml_option.valFromOption(j) < i) {
    Stdlib.invalid_arg("Re.repn");
  }
  return {
          TAG: /* Repeat */3,
          _0: r,
          _1: i,
          _2: j
        };
}

function rep(r) {
  return repn(r, 0, undefined);
}

function rep1(r) {
  return repn(r, 1, undefined);
}

function opt(r) {
  return repn(r, 0, 1);
}

function word(r) {
  return seq({
              hd: /* Beg_of_word */2,
              tl: {
                hd: r,
                tl: {
                  hd: /* End_of_word */3,
                  tl: /* [] */0
                }
              }
            });
}

function whole_string(r) {
  return seq({
              hd: /* Beg_of_str */5,
              tl: {
                hd: r,
                tl: {
                  hd: /* End_of_str */6,
                  tl: /* [] */0
                }
              }
            });
}

function longest(r) {
  return {
          TAG: /* Sem */4,
          _0: "Longest",
          _1: r
        };
}

function shortest(r) {
  return {
          TAG: /* Sem */4,
          _0: "Shortest",
          _1: r
        };
}

function first(r) {
  return {
          TAG: /* Sem */4,
          _0: "First",
          _1: r
        };
}

function greedy(r) {
  return {
          TAG: /* Sem_greedy */5,
          _0: "Greedy",
          _1: r
        };
}

function non_greedy(r) {
  return {
          TAG: /* Sem_greedy */5,
          _0: "Non_greedy",
          _1: r
        };
}

function group(r) {
  return {
          TAG: /* Group */6,
          _0: r
        };
}

function no_group(r) {
  return {
          TAG: /* No_group */7,
          _0: r
        };
}

function nest(r) {
  return {
          TAG: /* Nest */8,
          _0: r
        };
}

function mark(r) {
  var i = Pmark.gen(undefined);
  return [
          i,
          {
            TAG: /* Pmark */14,
            _0: i,
            _1: r
          }
        ];
}

function set(str) {
  var s = Cset.empty;
  for(var i = 0 ,i_finish = str.length; i < i_finish; ++i){
    s = Cset.union(Cset.csingle(Caml_string.get(str, i)), s);
  }
  return {
          TAG: /* Set */0,
          _0: s
        };
}

function rg(c, c$p) {
  return {
          TAG: /* Set */0,
          _0: Cset.seq(c, c$p)
        };
}

function inter(l) {
  var r = {
    TAG: /* Intersection */11,
    _0: l
  };
  if (is_charset(r)) {
    return r;
  } else {
    return Stdlib.invalid_arg("Re.inter");
  }
}

function compl(l) {
  var r = {
    TAG: /* Complement */12,
    _0: l
  };
  if (is_charset(r)) {
    return r;
  } else {
    return Stdlib.invalid_arg("Re.compl");
  }
}

function diff(r, r$p) {
  var r$p$p = {
    TAG: /* Difference */13,
    _0: r,
    _1: r$p
  };
  if (is_charset(r$p$p)) {
    return r$p$p;
  } else {
    return Stdlib.invalid_arg("Re.diff");
  }
}

var any = {
  TAG: /* Set */0,
  _0: Cset.cany
};

var notnl = {
  TAG: /* Set */0,
  _0: Cset.diff(Cset.cany, Cset.csingle(/* '\n' */10))
};

var lower = alt({
      hd: {
        TAG: /* Set */0,
        _0: Cset.seq(/* 'a' */97, /* 'z' */122)
      },
      tl: {
        hd: {
          TAG: /* Set */0,
          _0: Cset.csingle(/* '\181' */181)
        },
        tl: {
          hd: {
            TAG: /* Set */0,
            _0: Cset.seq(/* '\223' */223, /* '\246' */246)
          },
          tl: {
            hd: {
              TAG: /* Set */0,
              _0: Cset.seq(/* '\248' */248, /* '\255' */255)
            },
            tl: /* [] */0
          }
        }
      }
    });

var upper = alt({
      hd: {
        TAG: /* Set */0,
        _0: Cset.seq(/* 'A' */65, /* 'Z' */90)
      },
      tl: {
        hd: {
          TAG: /* Set */0,
          _0: Cset.seq(/* '\192' */192, /* '\214' */214)
        },
        tl: {
          hd: {
            TAG: /* Set */0,
            _0: Cset.seq(/* '\216' */216, /* '\222' */222)
          },
          tl: /* [] */0
        }
      }
    });

var alpha = alt({
      hd: lower,
      tl: {
        hd: upper,
        tl: {
          hd: {
            TAG: /* Set */0,
            _0: Cset.csingle(/* '\170' */170)
          },
          tl: {
            hd: {
              TAG: /* Set */0,
              _0: Cset.csingle(/* '\186' */186)
            },
            tl: /* [] */0
          }
        }
      }
    });

var digit = {
  TAG: /* Set */0,
  _0: Cset.seq(/* '0' */48, /* '9' */57)
};

var alnum = alt({
      hd: alpha,
      tl: {
        hd: digit,
        tl: /* [] */0
      }
    });

var wordc = alt({
      hd: alnum,
      tl: {
        hd: {
          TAG: /* Set */0,
          _0: Cset.csingle(/* '_' */95)
        },
        tl: /* [] */0
      }
    });

var ascii = {
  TAG: /* Set */0,
  _0: Cset.seq(/* '\000' */0, /* '\127' */127)
};

var blank = set("\t ");

var cntrl = alt({
      hd: {
        TAG: /* Set */0,
        _0: Cset.seq(/* '\000' */0, /* '\031' */31)
      },
      tl: {
        hd: {
          TAG: /* Set */0,
          _0: Cset.seq(/* '\127' */127, /* '\159' */159)
        },
        tl: /* [] */0
      }
    });

var graph = alt({
      hd: {
        TAG: /* Set */0,
        _0: Cset.seq(/* '!' */33, /* '~' */126)
      },
      tl: {
        hd: {
          TAG: /* Set */0,
          _0: Cset.seq(/* '\160' */160, /* '\255' */255)
        },
        tl: /* [] */0
      }
    });

var print = alt({
      hd: {
        TAG: /* Set */0,
        _0: Cset.seq(/* ' ' */32, /* '~' */126)
      },
      tl: {
        hd: {
          TAG: /* Set */0,
          _0: Cset.seq(/* '\160' */160, /* '\255' */255)
        },
        tl: /* [] */0
      }
    });

var punct = alt({
      hd: {
        TAG: /* Set */0,
        _0: Cset.seq(/* '!' */33, /* '/' */47)
      },
      tl: {
        hd: {
          TAG: /* Set */0,
          _0: Cset.seq(/* ':' */58, /* '@' */64)
        },
        tl: {
          hd: {
            TAG: /* Set */0,
            _0: Cset.seq(/* '[' */91, /* '`' */96)
          },
          tl: {
            hd: {
              TAG: /* Set */0,
              _0: Cset.seq(/* '{' */123, /* '~' */126)
            },
            tl: {
              hd: {
                TAG: /* Set */0,
                _0: Cset.seq(/* '\160' */160, /* '\169' */169)
              },
              tl: {
                hd: {
                  TAG: /* Set */0,
                  _0: Cset.seq(/* '\171' */171, /* '\180' */180)
                },
                tl: {
                  hd: {
                    TAG: /* Set */0,
                    _0: Cset.seq(/* '\182' */182, /* '\185' */185)
                  },
                  tl: {
                    hd: {
                      TAG: /* Set */0,
                      _0: Cset.seq(/* '\187' */187, /* '\191' */191)
                    },
                    tl: {
                      hd: {
                        TAG: /* Set */0,
                        _0: Cset.csingle(/* '\215' */215)
                      },
                      tl: {
                        hd: {
                          TAG: /* Set */0,
                          _0: Cset.csingle(/* '\247' */247)
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

var space = alt({
      hd: {
        TAG: /* Set */0,
        _0: Cset.csingle(/* ' ' */32)
      },
      tl: {
        hd: {
          TAG: /* Set */0,
          _0: Cset.seq(/* '\t' */9, /* '\r' */13)
        },
        tl: /* [] */0
      }
    });

var xdigit = alt({
      hd: digit,
      tl: {
        hd: {
          TAG: /* Set */0,
          _0: Cset.seq(/* 'a' */97, /* 'f' */102)
        },
        tl: {
          hd: {
            TAG: /* Set */0,
            _0: Cset.seq(/* 'A' */65, /* 'F' */70)
          },
          tl: /* [] */0
        }
      }
    });

function $$case(r) {
  return {
          TAG: /* Case */9,
          _0: r
        };
}

function no_case(r) {
  return {
          TAG: /* No_case */10,
          _0: r
        };
}

function compile(r) {
  var regexp = anchored(r) ? ({
        TAG: /* Group */6,
        _0: r
      }) : seq({
          hd: {
            TAG: /* Sem */4,
            _0: "Shortest",
            _1: repn(any, 0, undefined)
          },
          tl: {
            hd: {
              TAG: /* Group */6,
              _0: r
            },
            tl: /* [] */0
          }
        });
  var regexp$1 = handle_case(false, regexp);
  var c = Color_map.make(undefined);
  var need_lnl = colorize(c, regexp$1);
  var match = Color_map.flatten(c);
  var ncolor = match[2];
  var colors = match[0];
  var lnl = need_lnl ? ncolor : -1;
  var ncolor$1 = need_lnl ? ncolor + 1 | 0 : ncolor;
  var ids = Automata.create_ids(undefined);
  var pos = {
    contents: 0
  };
  var match$1 = translate(ids, "First", false, false, "Greedy", pos, {
        contents: Cset.CSetMap.empty
      }, colors, regexp$1);
  var r$1 = enforce_kind(ids, "First", match$1[1], match$1[0]);
  var color_repr = match[1];
  var group_count = pos.contents / 2 | 0;
  return {
          initial: r$1,
          initial_states: /* [] */0,
          colors: colors,
          color_repr: color_repr,
          ncolor: ncolor$1,
          lnl: lnl,
          tbl: Automata.create_working_area(undefined),
          states: Curry._1(Automata.State.Table.create, 97),
          group_count: group_count
        };
}

function exec_internal(name, posOpt, lenOpt, partial, groups, re, s) {
  var pos = posOpt !== undefined ? posOpt : 0;
  var len = lenOpt !== undefined ? lenOpt : -1;
  if (pos < 0 || len < -1 || (pos + len | 0) > s.length) {
    Stdlib.invalid_arg(name);
  }
  return match_str(groups, partial, re, s, pos, len);
}

function exec(pos, len, re, s) {
  var substr = exec_internal("Re.exec", pos, len, false, true, re, s);
  if (typeof substr === "number") {
    throw {
          RE_EXN_ID: Stdlib.Not_found,
          Error: new Error()
        };
  }
  return substr._0;
}

function exec_opt(pos, len, re, s) {
  var substr = exec_internal("Re.exec_opt", pos, len, false, true, re, s);
  if (typeof substr === "number") {
    return ;
  } else {
    return substr._0;
  }
}

function execp(pos, len, re, s) {
  var _substr = exec_internal("Re.execp", pos, len, false, false, re, s);
  if (typeof _substr === "number") {
    return false;
  } else {
    return true;
  }
}

function exec_partial(pos, len, re, s) {
  var match = exec_internal("Re.exec_partial", pos, len, true, false, re, s);
  if (typeof match === "number") {
    if (match) {
      return "Partial";
    } else {
      return "Mismatch";
    }
  } else {
    return "Full";
  }
}

function test(g, p) {
  return Curry._2(Pmark.$$Set.mem, p, g.pmarks);
}

function all(g) {
  return g.pmarks;
}

function all$1(posOpt, len, re, s) {
  var pos = posOpt !== undefined ? posOpt : 0;
  if (pos < 0) {
    Stdlib.invalid_arg("Re.all");
  }
  var limit = len !== undefined ? (len < 0 || (pos + len | 0) > s.length ? Stdlib.invalid_arg("Re.all") : undefined, pos + len | 0) : s.length;
  var aux = function (pos, param) {
    if (pos >= limit) {
      return /* Nil */0;
    }
    var substr = match_str(true, false, re, s, pos, limit - pos | 0);
    if (typeof substr === "number") {
      return /* Nil */0;
    }
    var substr$1 = substr._0;
    var match = Group.offset(substr$1, 0);
    var p2 = match[1];
    var pos$1 = match[0] === p2 ? p2 + 1 | 0 : p2;
    return /* Cons */{
            _0: substr$1,
            _1: (function (param) {
                return aux(pos$1, param);
              })
          };
  };
  return function (param) {
    return aux(pos, param);
  };
}

function matches(pos, len, re, s) {
  var partial_arg = all$1(pos, len, re, s);
  return function (param) {
    return Seq.map((function (sub) {
                  return Group.get(sub, 0);
                }), partial_arg, param);
  };
}

function split_full(posOpt, len, re, s) {
  var pos = posOpt !== undefined ? posOpt : 0;
  if (pos < 0) {
    Stdlib.invalid_arg("Re.split");
  }
  var limit = len !== undefined ? (len < 0 || (pos + len | 0) > s.length ? Stdlib.invalid_arg("Re.split") : undefined, pos + len | 0) : s.length;
  var aux = function (state, i, pos$1, param) {
    if (typeof state !== "string") {
      return /* Cons */{
              _0: state.VAL,
              _1: (function (param) {
                  return aux("Idle", i, pos$1, param);
                })
            };
    }
    if (pos$1 >= limit) {
      if (i >= limit) {
        return /* Nil */0;
      }
      var sub = $$String.sub(s, i, limit - i | 0);
      var partial_arg = i + 1 | 0;
      return /* Cons */{
              _0: {
                NAME: "Text",
                VAL: sub
              },
              _1: (function (param) {
                  return aux(state, partial_arg, pos$1, param);
                })
            };
    }
    var substr = match_str(true, false, re, s, pos$1, limit - pos$1 | 0);
    if (typeof substr === "number") {
      if (substr) {
        return /* Nil */0;
      }
      if (i >= limit) {
        return /* Nil */0;
      }
      var text = $$String.sub(s, i, limit - i | 0);
      return /* Cons */{
              _0: {
                NAME: "Text",
                VAL: text
              },
              _1: (function (param) {
                  return aux(state, limit, pos$1, param);
                })
            };
    }
    var substr$1 = substr._0;
    var match = Group.offset(substr$1, 0);
    var p2 = match[1];
    var p1 = match[0];
    var pos$2 = p1 === p2 ? p2 + 1 | 0 : p2;
    if (p1 <= pos) {
      return /* Cons */{
              _0: {
                NAME: "Delim",
                VAL: substr$1
              },
              _1: (function (param) {
                  return aux(state, p2, pos$2, param);
                })
            };
    }
    var text$1 = $$String.sub(s, i, p1 - i | 0);
    var state_1 = {
      NAME: "Delim",
      VAL: substr$1
    };
    var state$1 = {
      NAME: "Yield",
      VAL: state_1
    };
    return /* Cons */{
            _0: {
              NAME: "Text",
              VAL: text$1
            },
            _1: (function (param) {
                return aux(state$1, p2, pos$2, param);
              })
          };
  };
  return function (param) {
    return aux("Idle", pos, pos, param);
  };
}

function split(pos, len, re, s) {
  var seq = split_full(pos, len, re, s);
  var filter = function (_seq, _param) {
    while(true) {
      var seq = _seq;
      var match = Curry._1(seq, undefined);
      if (!match) {
        return /* Nil */0;
      }
      var match$1 = match._0;
      if (match$1.NAME === "Text") {
        var tl = match._1;
        return /* Cons */{
                _0: match$1.VAL,
                _1: (function(tl){
                return function (param) {
                  return filter(tl, param);
                }
                }(tl))
              };
      }
      _param = undefined;
      _seq = match._1;
      continue ;
    };
  };
  return function (param) {
    return filter(seq, param);
  };
}

function list_of_seq(s) {
  return List.rev(Seq.fold_left((function (l, x) {
                    return {
                            hd: x,
                            tl: l
                          };
                  }), /* [] */0, s));
}

function all$2(pos, len, re, s) {
  return list_of_seq(all$1(pos, len, re, s));
}

function matches$1(pos, len, re, s) {
  return list_of_seq(matches(pos, len, re, s));
}

function split_full$1(pos, len, re, s) {
  return list_of_seq(split_full(pos, len, re, s));
}

function split$1(pos, len, re, s) {
  return list_of_seq(split(pos, len, re, s));
}

function gen_of_seq(s) {
  var r = {
    contents: s
  };
  return function (param) {
    var match = Curry._1(r.contents, undefined);
    if (match) {
      r.contents = match._1;
      return Caml_option.some(match._0);
    }
    
  };
}

function split$2(pos, len, re, s) {
  return gen_of_seq(split(pos, len, re, s));
}

function split_full$2(pos, len, re, s) {
  return gen_of_seq(split_full(pos, len, re, s));
}

function all$3(pos, len, re, s) {
  return gen_of_seq(all$1(pos, len, re, s));
}

function matches$2(pos, len, re, s) {
  return gen_of_seq(matches(pos, len, re, s));
}

function replace(posOpt, len, allOpt, re, f, s) {
  var pos = posOpt !== undefined ? posOpt : 0;
  var all = allOpt !== undefined ? allOpt : true;
  if (pos < 0) {
    Stdlib.invalid_arg("Re.replace");
  }
  var limit = len !== undefined ? (len < 0 || (pos + len | 0) > s.length ? Stdlib.invalid_arg("Re.replace") : undefined, pos + len | 0) : s.length;
  var buf = $$Buffer.create(s.length);
  var iter = function (_pos) {
    while(true) {
      var pos = _pos;
      if (pos >= limit) {
        return ;
      }
      var substr = match_str(true, false, re, s, pos, limit - pos | 0);
      if (typeof substr === "number") {
        if (substr) {
          return ;
        } else {
          return $$Buffer.add_substring(buf, s, pos, limit - pos | 0);
        }
      }
      var substr$1 = substr._0;
      var match = Group.offset(substr$1, 0);
      var p2 = match[1];
      var p1 = match[0];
      $$Buffer.add_substring(buf, s, pos, p1 - pos | 0);
      var replacing = Curry._1(f, substr$1);
      $$Buffer.add_string(buf, replacing);
      if (!all) {
        return $$Buffer.add_substring(buf, s, p2, limit - p2 | 0);
      }
      _pos = p1 === p2 ? (p2 < limit ? $$Buffer.add_char(buf, Caml_string.get(s, p2)) : undefined, p2 + 1 | 0) : p2;
      continue ;
    };
  };
  iter(pos);
  return $$Buffer.contents(buf);
}

function replace_string(pos, len, all, re, by, s) {
  return replace(pos, len, all, re, (function (param) {
                return by;
              }), s);
}

function witness(t) {
  var witness$1 = function (_c) {
    while(true) {
      var c = _c;
      if (typeof c === "number") {
        return "";
      }
      switch (c.TAG | 0) {
        case /* Set */0 :
            return $$String.make(1, Char.chr(Cset.pick(c._0)));
        case /* Sequence */1 :
            return $$String.concat("", List.map(witness$1, c._0));
        case /* Alternative */2 :
            var match = c._0;
            if (match) {
              _c = match.hd;
              continue ;
            }
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "core.re",
                    1563,
                    25
                  ],
                  Error: new Error()
                };
        case /* Repeat */3 :
            var from = c._1;
            var w = witness$1(c._0);
            var b = $$Buffer.create(Math.imul(w.length, from));
            for(var _i = 1; _i <= from; ++_i){
              $$Buffer.add_string(b, w);
            }
            return $$Buffer.contents(b);
        case /* Group */6 :
        case /* No_group */7 :
        case /* Nest */8 :
        case /* Case */9 :
        case /* No_case */10 :
            _c = c._0;
            continue ;
        case /* Intersection */11 :
        case /* Complement */12 :
        case /* Difference */13 :
            break;
        case /* Sem */4 :
        case /* Sem_greedy */5 :
        case /* Pmark */14 :
            _c = c._1;
            continue ;
        
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "core.re",
              1575,
              44
            ],
            Error: new Error()
          };
    };
  };
  return witness$1(handle_case(false, t));
}

var Group$1 = Group;

var Mark = {
  test: test,
  $$Set: Pmark.$$Set,
  all: all,
  equal: Pmark.equal,
  compare: Pmark.compare
};

var Seq$1 = {
  all: all$1,
  matches: matches,
  split: split,
  split_full: split_full
};

var all_gen = all$3;

var matches_gen = matches$2;

var split_gen = split$2;

var split_full_gen = split_full$2;

var bol = /* Beg_of_line */0;

var eol = /* End_of_line */1;

var bow = /* Beg_of_word */2;

var eow = /* End_of_word */3;

var bos = /* Beg_of_str */5;

var eos = /* End_of_str */6;

var leol = /* Last_end_of_line */7;

var start = /* Start */8;

var stop = /* Stop */9;

var not_boundary = /* Not_bound */4;

var print_re = pp_re;

var get = Group.get;

var get_ofs = Group.offset;

var get_all = Group.all;

var get_all_ofs = Group.all_offset;

var test$1 = Group.test;

var marked = test;

var mark_set = all;

export {
  Group$1 as Group,
  compile ,
  exec ,
  exec_opt ,
  execp ,
  exec_partial ,
  Mark ,
  Seq$1 as Seq,
  all$2 as all,
  all_gen ,
  matches$1 as matches,
  matches_gen ,
  split$1 as split,
  split_gen ,
  split_full$1 as split_full,
  split_full_gen ,
  replace ,
  replace_string ,
  str ,
  $$char ,
  alt ,
  seq ,
  empty ,
  epsilon ,
  rep ,
  rep1 ,
  repn ,
  opt ,
  bol ,
  eol ,
  bow ,
  eow ,
  bos ,
  eos ,
  leol ,
  start ,
  stop ,
  word ,
  not_boundary ,
  whole_string ,
  longest ,
  shortest ,
  first ,
  greedy ,
  non_greedy ,
  group ,
  no_group ,
  nest ,
  mark ,
  set ,
  rg ,
  inter ,
  diff ,
  compl ,
  any ,
  notnl ,
  alnum ,
  wordc ,
  alpha ,
  ascii ,
  blank ,
  cntrl ,
  digit ,
  graph ,
  lower ,
  print ,
  punct ,
  space ,
  upper ,
  xdigit ,
  $$case ,
  no_case ,
  pp ,
  pp_re ,
  print_re ,
  View ,
  witness ,
  get ,
  get_ofs ,
  get_all ,
  get_all_ofs ,
  test$1 as test,
  marked ,
  mark_set ,
  
}
/* cupper Not a pure module */
