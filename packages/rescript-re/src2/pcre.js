// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core from "./core.js";
import * as List from "@rescript/std/lib/es6/list.js";
import * as Perl from "./perl.js";
import * as Bytes from "@rescript/std/lib/es6/bytes.js";
import * as Curry from "@rescript/std/lib/es6/curry.js";
import * as $$Buffer from "@rescript/std/lib/es6/buffer.js";
import * as $$String from "@rescript/std/lib/es6/string.js";
import * as Caml_obj from "@rescript/std/lib/es6/caml_obj.js";
import * as Caml_array from "@rescript/std/lib/es6/caml_array.js";
import * as Caml_bytes from "@rescript/std/lib/es6/caml_bytes.js";

function re(flagsOpt, pat) {
  var flags = flagsOpt !== undefined ? flagsOpt : /* [] */0;
  var opts = List.map((function (param) {
          if (param === "CASELESS") {
            return "Caseless";
          } else if (param === "ANCHORED") {
            return "Anchored";
          } else {
            return "Multiline";
          }
        }), flags);
  return Perl.re(opts, pat);
}

function regexp(flags, pat) {
  return Core.compile(re(flags, pat));
}

function extract(rex, s) {
  return Curry._1(Core.Group.all, Core.exec(undefined, undefined, rex, s));
}

function exec(rex, pos, s) {
  return Core.exec(pos, undefined, rex, s);
}

function get_substring(s, i) {
  return Curry._2(Core.Group.get, s, i);
}

function get_substring_ofs(s, i) {
  return Curry._2(Core.Group.offset, s, i);
}

function pmatch(rex, s) {
  return Core.execp(undefined, undefined, rex, s);
}

function substitute(rex, subst, str) {
  var b = $$Buffer.create(1024);
  var _pos = 0;
  while(true) {
    var pos = _pos;
    if (pos >= str.length) {
      return $$Buffer.contents(b);
    }
    if (Core.execp(pos, undefined, rex, str)) {
      var ss = Core.exec(pos, undefined, rex, str);
      var match = Curry._2(Core.Group.offset, ss, 0);
      var pat = Curry._2(Core.Group.get, ss, 0);
      $$Buffer.add_substring(b, str, pos, match[0] - pos | 0);
      $$Buffer.add_string(b, Curry._1(subst, pat));
      _pos = match[1];
      continue ;
    }
    $$Buffer.add_substring(b, str, pos, str.length - pos | 0);
    _pos = str.length;
    continue ;
  };
}

function split(rex, str) {
  var _accu = /* [] */0;
  var _pos = 0;
  while(true) {
    var pos = _pos;
    var accu = _accu;
    if (pos >= str.length) {
      return List.rev(accu);
    }
    if (Core.execp(pos, undefined, rex, str)) {
      var ss = Core.exec(pos, undefined, rex, str);
      var match = Curry._2(Core.Group.offset, ss, 0);
      var s = $$String.sub(str, pos, match[0] - pos | 0);
      _pos = match[1];
      _accu = {
        hd: s,
        tl: accu
      };
      continue ;
    }
    var s$1 = $$String.sub(str, pos, str.length - pos | 0);
    _pos = str.length;
    _accu = {
      hd: s$1,
      tl: accu
    };
    continue ;
  };
}

function quote(s) {
  var len = s.length;
  var buf = Caml_bytes.caml_create_bytes((len << 1));
  var pos = 0;
  for(var i = 0; i < len; ++i){
    var c = s.charCodeAt(i);
    var exit = 0;
    if (c >= 91) {
      exit = c > 122 || c < 93 ? (
          c >= 125 ? 1 : 2
        ) : (
          c !== 94 ? 1 : 2
        );
    } else if (c >= 47) {
      exit = c !== 63 ? 1 : 2;
    } else if (c >= 36) {
      switch (c) {
        case 37 :
        case 38 :
        case 39 :
        case 44 :
        case 45 :
            exit = 1;
            break;
        case 36 :
        case 40 :
        case 41 :
        case 42 :
        case 43 :
        case 46 :
            exit = 2;
            break;
        
      }
    } else {
      exit = 1;
    }
    switch (exit) {
      case 1 :
          buf[pos] = c;
          pos = pos + 1 | 0;
          break;
      case 2 :
          buf[pos] = /* '\\' */92;
          pos = pos + 1 | 0;
          buf[pos] = c;
          pos = pos + 1 | 0;
          break;
      
    }
  }
  var ofs = 0;
  var r = Caml_bytes.caml_create_bytes(pos);
  Caml_bytes.caml_blit_bytes(buf, ofs, r, 0, pos);
  return Bytes.unsafe_to_string(r);
}

function full_split(maxOpt, rex, s) {
  var max = maxOpt !== undefined ? maxOpt : 0;
  if (s.length === 0) {
    return /* [] */0;
  }
  if (max === 1) {
    return {
            hd: {
              TAG: /* Text */0,
              _0: s
            },
            tl: /* [] */0
          };
  }
  var results = Core.split_full(undefined, undefined, rex, s);
  return List.concat(List.map((function (param) {
                    if (param.NAME === "Text") {
                      return {
                              hd: {
                                TAG: /* Text */0,
                                _0: param.VAL
                              },
                              tl: /* [] */0
                            };
                    }
                    var d = param.VAL;
                    var matches = Curry._1(Core.Group.all_offset, d);
                    var delim = Curry._2(Core.Group.get, d, 0);
                    var l = /* [] */0;
                    for(var i = 1 ,i_finish = matches.length; i < i_finish; ++i){
                      l = {
                        hd: Caml_obj.caml_equal(Caml_array.get(matches, i), [
                              -1,
                              -1
                            ]) ? /* NoGroup */0 : ({
                              TAG: /* Group */2,
                              _0: i,
                              _1: Curry._2(Core.Group.get, d, i)
                            }),
                        tl: l
                      };
                    }
                    return {
                            hd: {
                              TAG: /* Delim */1,
                              _0: delim
                            },
                            tl: List.rev(l)
                          };
                  }), results));
}

export {
  re ,
  regexp ,
  extract ,
  exec ,
  get_substring ,
  get_substring_ofs ,
  pmatch ,
  substitute ,
  full_split ,
  split ,
  quote ,
  
}
/* Core Not a pure module */
