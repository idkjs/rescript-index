// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core from "./core.js";
import * as List from "@rescript/std/lib/es6/list.js";
import * as Bytes from "@rescript/std/lib/es6/bytes.js";
import * as Curry from "@rescript/std/lib/es6/curry.js";
import * as Emacs from "./emacs.js";
import * as $$Buffer from "@rescript/std/lib/es6/buffer.js";
import * as $$String from "@rescript/std/lib/es6/string.js";
import * as Caml_bytes from "@rescript/std/lib/es6/caml_bytes.js";
import * as Pervasives from "@rescript/std/lib/es6/pervasives.js";
import * as Caml_option from "@rescript/std/lib/es6/caml_option.js";
import * as Caml_string from "@rescript/std/lib/es6/caml_string.js";
import * as CamlinternalLazy from "@rescript/std/lib/es6/camlinternalLazy.js";
import * as Caml_js_exceptions from "@rescript/std/lib/es6/caml_js_exceptions.js";

function compile_regexp(s, c) {
  var re = Emacs.re(!c, s);
  return {
          re: re,
          mtch: {
            LAZY_DONE: false,
            VAL: (function () {
                return Core.compile(Core.seq({
                                hd: Core.start,
                                tl: {
                                  hd: re,
                                  tl: /* [] */0
                                }
                              }));
              })
          },
          srch: {
            LAZY_DONE: false,
            VAL: (function () {
                return Core.compile(re);
              })
          }
        };
}

var state = {
  contents: undefined
};

function string_match(re, s, p) {
  try {
    state.contents = Caml_option.some(Core.exec(p, undefined, CamlinternalLazy.force(re.mtch), s));
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      state.contents = undefined;
      return false;
    }
    throw exn;
  }
}

function string_partial_match(re, s, p) {
  var match = Core.exec_partial(p, undefined, CamlinternalLazy.force(re.mtch), s);
  if (match === "Full") {
    return string_match(re, s, p);
  } else {
    return match === "Partial";
  }
}

function search_forward(re, s, p) {
  try {
    var res = Core.exec(p, undefined, CamlinternalLazy.force(re.srch), s);
    state.contents = Caml_option.some(res);
    return Curry._2(Core.Group.offset, res, 0)[0];
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      state.contents = undefined;
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    throw exn;
  }
}

function search_backward(re, s, _p) {
  while(true) {
    var p = _p;
    try {
      var res = Core.exec(p, undefined, CamlinternalLazy.force(re.mtch), s);
      state.contents = Caml_option.some(res);
      return p;
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        state.contents = undefined;
        if (p === 0) {
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        _p = p - 1 | 0;
        continue ;
      }
      throw exn;
    }
  };
}

function valid_group(n) {
  if (n < 0) {
    return false;
  }
  if (n >= 10) {
    return false;
  }
  var m = state.contents;
  if (m !== undefined) {
    return n < Curry._1(Core.Group.nb_groups, Caml_option.valFromOption(m));
  } else {
    return false;
  }
}

function offset_group(i) {
  var m = state.contents;
  if (m !== undefined) {
    return Curry._2(Core.Group.offset, Caml_option.valFromOption(m), i);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function group_len(i) {
  try {
    var match = offset_group(i);
    return match[1] - match[0] | 0;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      return 0;
    }
    throw exn;
  }
}

function repl_length(repl, _p, _q, len) {
  while(true) {
    var q = _q;
    var p = _p;
    if (p >= len) {
      return q;
    }
    if (Caml_string.get(repl, p) !== /* '\\' */92) {
      _q = q + 1 | 0;
      _p = p + 1 | 0;
      continue ;
    }
    var p$1 = p + 1 | 0;
    if (p$1 === len) {
      Pervasives.failwith("Str.replace: illegal backslash sequence");
    }
    var c = Caml_string.get(repl, p$1);
    var q$1 = c >= 58 ? (
        c !== 92 ? q + 2 | 0 : q + 1 | 0
      ) : (
        c >= 48 ? q + group_len(c - /* '0' */48 | 0) | 0 : q + 2 | 0
      );
    _q = q$1;
    _p = p$1 + 1 | 0;
    continue ;
  };
}

function replace(orig, repl, _p, res, _q, len) {
  while(true) {
    var q = _q;
    var p = _p;
    if (p >= len) {
      return ;
    }
    var c = Caml_string.get(repl, p);
    if (c !== /* '\\' */92) {
      Caml_bytes.set(res, q, c);
      _q = q + 1 | 0;
      _p = p + 1 | 0;
      continue ;
    }
    var c$1 = Caml_string.get(repl, p + 1 | 0);
    if (c$1 >= 58) {
      if (c$1 === 92) {
        Caml_bytes.set(res, q, /* '\\' */92);
        _q = q + 1 | 0;
        _p = p + 2 | 0;
        continue ;
      }
      
    } else if (c$1 >= 48) {
      var d;
      try {
        var match = offset_group(c$1 - /* '0' */48 | 0);
        var b = match[0];
        var d$1 = match[1] - b | 0;
        if (d$1 > 0) {
          $$String.blit(orig, b, res, q, d$1);
        }
        d = d$1;
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          d = 0;
        } else {
          throw exn;
        }
      }
      _q = q + d | 0;
      _p = p + 2 | 0;
      continue ;
    }
    Caml_bytes.set(res, q, /* '\\' */92);
    Caml_bytes.set(res, q + 1 | 0, c$1);
    _q = q + 2 | 0;
    _p = p + 2 | 0;
    continue ;
  };
}

function replacement_text(repl, orig) {
  var len = repl.length;
  var res = Caml_bytes.caml_create_bytes(repl_length(repl, 0, 0, len));
  replace(orig, repl, 0, res, 0, repl.length);
  return Bytes.unsafe_to_string(res);
}

function quote(s) {
  var len = s.length;
  var buf = $$Buffer.create((len << 1));
  for(var i = 0; i < len; ++i){
    var c = Caml_string.get(s, i);
    var exit = 0;
    if (c > 94 || c < 63) {
      switch (c) {
        case 37 :
        case 38 :
        case 39 :
        case 40 :
        case 41 :
        case 44 :
        case 45 :
            $$Buffer.add_char(buf, c);
            break;
        case 36 :
        case 42 :
        case 43 :
        case 46 :
            exit = 1;
            break;
        default:
          $$Buffer.add_char(buf, c);
      }
    } else if (c > 90 || c < 64) {
      exit = 1;
    } else {
      $$Buffer.add_char(buf, c);
    }
    if (exit === 1) {
      $$Buffer.add_char(buf, /* '\\' */92);
      $$Buffer.add_char(buf, c);
    }
    
  }
  return $$Buffer.contents(buf);
}

function string_before(s, n) {
  return $$String.sub(s, 0, n);
}

function string_after(s, n) {
  return $$String.sub(s, n, s.length - n | 0);
}

function first_chars(s, n) {
  return $$String.sub(s, 0, n);
}

function last_chars(s, n) {
  return $$String.sub(s, s.length - n | 0, n);
}

function regexp(e) {
  return compile_regexp(e, false);
}

function regexp_case_fold(e) {
  return compile_regexp(e, true);
}

function regexp_string(s) {
  return compile_regexp(quote(s), false);
}

function regexp_string_case_fold(s) {
  return compile_regexp(quote(s), true);
}

function group_beginning(n) {
  if (!valid_group(n)) {
    Pervasives.invalid_arg("Str.group_beginning");
  }
  var pos = offset_group(n)[0];
  if (pos === -1) {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  return pos;
}

function group_end(n) {
  if (!valid_group(n)) {
    Pervasives.invalid_arg("Str.group_end");
  }
  var pos = offset_group(n)[1];
  if (pos === -1) {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  return pos;
}

function matched_group(n, txt) {
  var match = offset_group(n);
  var b = match[0];
  return $$String.sub(txt, b, match[1] - b | 0);
}

var replace_matched = replacement_text;

function match_beginning(param) {
  return group_beginning(0);
}

function match_end(param) {
  return group_end(0);
}

function matched_string(txt) {
  return matched_group(0, txt);
}

function substitute_first(expr, repl_fun, text) {
  try {
    var pos = search_forward(expr, text, 0);
    return $$String.concat("", {
                hd: $$String.sub(text, 0, pos),
                tl: {
                  hd: Curry._1(repl_fun, text),
                  tl: {
                    hd: string_after(text, group_end(0)),
                    tl: /* [] */0
                  }
                }
              });
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      return text;
    }
    throw exn;
  }
}

function global_substitute(expr, repl_fun, text) {
  var replace = function (_accu, _start, _last_was_empty) {
    while(true) {
      var last_was_empty = _last_was_empty;
      var start = _start;
      var accu = _accu;
      var startpos = last_was_empty ? start + 1 | 0 : start;
      if (startpos > text.length) {
        return {
                hd: string_after(text, start),
                tl: accu
              };
      }
      var pos;
      try {
        pos = search_forward(expr, text, startpos);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return {
                  hd: string_after(text, start),
                  tl: accu
                };
        }
        throw exn;
      }
      var end_pos = group_end(0);
      var repl_text = Curry._1(repl_fun, text);
      _last_was_empty = end_pos === pos;
      _start = end_pos;
      _accu = {
        hd: repl_text,
        tl: {
          hd: $$String.sub(text, start, pos - start | 0),
          tl: accu
        }
      };
      continue ;
    };
  };
  return $$String.concat("", List.rev(replace(/* [] */0, 0, false)));
}

function global_replace(expr, repl, text) {
  return global_substitute(expr, (function (param) {
                return replacement_text(repl, param);
              }), text);
}

function replace_first(expr, repl, text) {
  return substitute_first(expr, (function (param) {
                return replacement_text(repl, param);
              }), text);
}

function search_forward_progress(re, s, p) {
  var pos = search_forward(re, s, p);
  if (group_end(0) > p) {
    return pos;
  }
  if (p < s.length) {
    return search_forward(re, s, p + 1 | 0);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function bounded_split(expr, text, num) {
  var start = string_match(expr, text, 0) ? group_end(0) : 0;
  var split = function (accu, start, n) {
    if (start >= text.length) {
      return accu;
    }
    if (n === 1) {
      return {
              hd: string_after(text, start),
              tl: accu
            };
    }
    try {
      var pos = search_forward_progress(expr, text, start);
      return split({
                  hd: $$String.sub(text, start, pos - start | 0),
                  tl: accu
                }, group_end(0), n - 1 | 0);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return {
                hd: string_after(text, start),
                tl: accu
              };
      }
      throw exn;
    }
  };
  return List.rev(split(/* [] */0, start, num));
}

function split(expr, text) {
  return bounded_split(expr, text, 0);
}

function bounded_split_delim(expr, text, num) {
  var split = function (accu, start, n) {
    if (start > text.length) {
      return accu;
    }
    if (n === 1) {
      return {
              hd: string_after(text, start),
              tl: accu
            };
    }
    try {
      var pos = search_forward_progress(expr, text, start);
      return split({
                  hd: $$String.sub(text, start, pos - start | 0),
                  tl: accu
                }, group_end(0), n - 1 | 0);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return {
                hd: string_after(text, start),
                tl: accu
              };
      }
      throw exn;
    }
  };
  if (text === "") {
    return /* [] */0;
  } else {
    return List.rev(split(/* [] */0, 0, num));
  }
}

function split_delim(expr, text) {
  return bounded_split_delim(expr, text, 0);
}

function bounded_full_split(expr, text, num) {
  var split = function (accu, start, n) {
    if (start >= text.length) {
      return accu;
    }
    if (n === 1) {
      return {
              hd: {
                TAG: /* Text */0,
                _0: string_after(text, start)
              },
              tl: accu
            };
    }
    try {
      var pos = search_forward_progress(expr, text, start);
      var s = matched_group(0, text);
      if (pos > start) {
        return split({
                    hd: {
                      TAG: /* Delim */1,
                      _0: s
                    },
                    tl: {
                      hd: {
                        TAG: /* Text */0,
                        _0: $$String.sub(text, start, pos - start | 0)
                      },
                      tl: accu
                    }
                  }, group_end(0), n - 1 | 0);
      } else {
        return split({
                    hd: {
                      TAG: /* Delim */1,
                      _0: s
                    },
                    tl: accu
                  }, group_end(0), n - 1 | 0);
      }
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return {
                hd: {
                  TAG: /* Text */0,
                  _0: string_after(text, start)
                },
                tl: accu
              };
      }
      throw exn;
    }
  };
  return List.rev(split(/* [] */0, 0, num));
}

function full_split(expr, text) {
  return bounded_full_split(expr, text, 0);
}

export {
  regexp ,
  regexp_case_fold ,
  quote ,
  regexp_string ,
  regexp_string_case_fold ,
  string_match ,
  search_forward ,
  search_backward ,
  string_partial_match ,
  matched_string ,
  match_beginning ,
  match_end ,
  matched_group ,
  group_beginning ,
  group_end ,
  global_replace ,
  replace_first ,
  global_substitute ,
  substitute_first ,
  replace_matched ,
  split ,
  bounded_split ,
  split_delim ,
  bounded_split_delim ,
  full_split ,
  bounded_full_split ,
  string_before ,
  string_after ,
  first_chars ,
  last_chars ,
  
}
/* Core Not a pure module */
