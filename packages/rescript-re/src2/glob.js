// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core from "./core.js";
import * as List from "@rescript/std/lib/es6/list.js";
import * as $$String from "@rescript/std/lib/es6/string.js";
import * as Pervasives from "@rescript/std/lib/es6/pervasives.js";
import * as Caml_string from "@rescript/std/lib/es6/caml_string.js";
import * as Caml_exceptions from "@rescript/std/lib/es6/caml_exceptions.js";

var Parse_error = /* @__PURE__ */Caml_exceptions.create("Glob.Parse_error");

function of_string(double_asterisk, s) {
  var i = {
    contents: 0
  };
  var l = s.length;
  var read = function (c) {
    var r = i.contents !== l && Caml_string.get(s, i.contents) === c;
    if (r) {
      i.contents = i.contents + 1 | 0;
    }
    return r;
  };
  var $$char = function (param) {
    read(/* '\\' */92);
    if (i.contents === l) {
      throw {
            RE_EXN_ID: Parse_error,
            Error: new Error()
          };
    }
    var r = Caml_string.get(s, i.contents);
    i.contents = i.contents + 1 | 0;
    return r;
  };
  var enclosed = function (param) {
    var _s = /* [] */0;
    while(true) {
      var s = _s;
      if (s !== /* [] */0 && read(/* ']' */93)) {
        return s;
      }
      var c = $$char(undefined);
      if (read(/* '-' */45)) {
        if (read(/* ']' */93)) {
          return {
                  hd: {
                    TAG: /* Char */0,
                    _0: c
                  },
                  tl: {
                    hd: {
                      TAG: /* Char */0,
                      _0: /* '-' */45
                    },
                    tl: s
                  }
                };
        }
        var c$p = $$char(undefined);
        _s = {
          hd: {
            TAG: /* Range */1,
            _0: c,
            _1: c$p
          },
          tl: s
        };
        continue ;
      }
      _s = {
        hd: {
          TAG: /* Char */0,
          _0: c
        },
        tl: s
      };
      continue ;
    };
  };
  var piece = function (param) {
    if (read(/* '*' */42)) {
      if (double_asterisk && read(/* '*' */42)) {
        return /* ManyMany */2;
      } else {
        return /* Many */1;
      }
    } else if (read(/* '?' */63)) {
      return /* One */0;
    } else if (read(/* '[' */91)) {
      if (read(/* '^' */94) || read(/* '!' */33)) {
        return {
                TAG: /* Any_but */2,
                _0: enclosed(undefined)
              };
      } else {
        return {
                TAG: /* Any_of */1,
                _0: enclosed(undefined)
              };
      }
    } else {
      return {
              TAG: /* Exactly */0,
              _0: $$char(undefined)
            };
    }
  };
  var _pieces = /* [] */0;
  while(true) {
    var pieces = _pieces;
    if (i.contents === l) {
      return List.rev(pieces);
    }
    _pieces = {
      hd: piece(undefined),
      tl: pieces
    };
    continue ;
  };
}

function mul(l, l$p) {
  return List.flatten(List.map((function (s) {
                    return List.map((function (s$p) {
                                  return s + s$p;
                                }), l$p);
                  }), l));
}

function explode(str) {
  var l = str.length;
  var expl = function (inner, _s, _i, _acc, _beg) {
    while(true) {
      var beg = _beg;
      var acc = _acc;
      var i = _i;
      var s = _s;
      if (i >= l) {
        if (inner) {
          throw {
                RE_EXN_ID: Parse_error,
                Error: new Error()
              };
        }
        return [
                mul(beg, {
                      hd: $$String.sub(str, s, i - s | 0),
                      tl: /* [] */0
                    }),
                i
              ];
      }
      var match = Caml_string.get(str, i);
      if (match !== 44) {
        if (match >= 123) {
          if (match < 126) {
            switch (match) {
              case 123 :
                  var match$1 = expl(true, i + 1 | 0, i + 1 | 0, /* [] */0, {
                        hd: "",
                        tl: /* [] */0
                      });
                  var i$p = match$1[1];
                  _beg = mul(beg, mul({
                            hd: $$String.sub(str, s, i - s | 0),
                            tl: /* [] */0
                          }, match$1[0]));
                  _i = i$p;
                  _s = i$p;
                  continue ;
              case 124 :
                  break;
              case 125 :
                  if (inner) {
                    return [
                            Pervasives.$at(mul(beg, {
                                      hd: $$String.sub(str, s, i - s | 0),
                                      tl: /* [] */0
                                    }), acc),
                            i + 1 | 0
                          ];
                  }
                  break;
              
            }
          }
          
        } else if (match === 92) {
          _i = i + 2 | 0;
          continue ;
        }
        
      } else if (inner) {
        _beg = {
          hd: "",
          tl: /* [] */0
        };
        _acc = Pervasives.$at(mul(beg, {
                  hd: $$String.sub(str, s, i - s | 0),
                  tl: /* [] */0
                }), acc);
        _i = i + 1 | 0;
        _s = i + 1 | 0;
        continue ;
      }
      _i = i + 1 | 0;
      continue ;
    };
  };
  return List.rev(expl(false, 0, 0, /* [] */0, {
                    hd: "",
                    tl: /* [] */0
                  })[0]);
}

function create(period, pathname, remaining) {
  return {
          re_pieces: /* [] */0,
          remaining: remaining,
          am_at_start_of_pattern: true,
          am_at_start_of_component: true,
          pathname: pathname,
          period: period
        };
}

function explicit_period(t) {
  if (t.period) {
    if (t.am_at_start_of_pattern) {
      return true;
    } else if (t.am_at_start_of_component) {
      return t.pathname;
    } else {
      return false;
    }
  } else {
    return false;
  }
}

function append(am_at_start_of_componentOpt, t, piece) {
  var am_at_start_of_component = am_at_start_of_componentOpt !== undefined ? am_at_start_of_componentOpt : false;
  return {
          re_pieces: {
            hd: piece,
            tl: t.re_pieces
          },
          remaining: t.remaining,
          am_at_start_of_pattern: false,
          am_at_start_of_component: am_at_start_of_component,
          pathname: t.pathname,
          period: t.period
        };
}

function next(t) {
  var match = t.remaining;
  if (match) {
    return [
            match.hd,
            {
              re_pieces: t.re_pieces,
              remaining: match.tl,
              am_at_start_of_pattern: t.am_at_start_of_pattern,
              am_at_start_of_component: t.am_at_start_of_component,
              pathname: t.pathname,
              period: t.period
            }
          ];
  }
  
}

function one(explicit_slash, explicit_period) {
  return Core.compl(List.concat({
                  hd: explicit_slash ? ({
                        hd: Core.$$char(/* '/' */47),
                        tl: /* [] */0
                      }) : /* [] */0,
                  tl: {
                    hd: explicit_period ? ({
                          hd: Core.$$char(/* '.' */46),
                          tl: /* [] */0
                        }) : /* [] */0,
                    tl: /* [] */0
                  }
                }));
}

function enclosed(enclosed$1) {
  if (enclosed$1.TAG === /* Char */0) {
    return Core.$$char(enclosed$1._0);
  } else {
    return Core.rg(enclosed$1._0, enclosed$1._1);
  }
}

function enclosed_set(explicit_slash, explicit_period, kind, set) {
  var set$1 = List.map(enclosed, set);
  var enclosure = kind === "Any_of" ? Core.alt(set$1) : Core.compl(set$1);
  return Core.inter({
              hd: enclosure,
              tl: {
                hd: one(explicit_slash, explicit_period),
                tl: /* [] */0
              }
            });
}

function exactly(state, c) {
  return append(c === /* '/' */47, state, Core.$$char(c));
}

function many_many(state) {
  var explicit_period$1 = state.period && state.pathname;
  var first_explicit_period = explicit_period(state);
  var match_component = function (explicit_period) {
    return Core.seq({
                hd: one(true, explicit_period),
                tl: {
                  hd: Core.rep(one(true, false)),
                  tl: /* [] */0
                }
              });
  };
  return append(undefined, state, Core.seq({
                  hd: Core.opt(match_component(first_explicit_period)),
                  tl: {
                    hd: Core.rep(Core.seq({
                              hd: Core.$$char(/* '/' */47),
                              tl: {
                                hd: Core.opt(match_component(explicit_period$1)),
                                tl: /* [] */0
                              }
                            })),
                    tl: /* [] */0
                  }
                }));
}

function piece(state, piece$1) {
  var explicit_slash = state.pathname;
  var explicit_period$1 = explicit_period(state);
  if (typeof piece$1 === "number") {
    switch (piece$1) {
      case /* One */0 :
          return append(undefined, state, one(explicit_slash, explicit_period$1));
      case /* Many */1 :
          var explicit_slash$1 = state.pathname;
          var explicit_period$2 = explicit_period(state);
          if (!explicit_period$2) {
            return append(undefined, state, Core.rep(one(explicit_slash$1, explicit_period$2)));
          }
          if (!explicit_slash$1) {
            return append(undefined, state, Core.opt(Core.seq({
                                hd: one(false, explicit_period$2),
                                tl: {
                                  hd: Core.rep(one(false, false)),
                                  tl: /* [] */0
                                }
                              })));
          }
          var not_empty = Core.seq({
                hd: one(true, true),
                tl: {
                  hd: Core.rep(one(true, false)),
                  tl: /* [] */0
                }
              });
          var maybe_empty = Core.opt(not_empty);
          var enclosed_set$1 = function (state, kind, set) {
            return append(undefined, state, Core.alt({
                            hd: enclosed_set(true, true, kind, set),
                            tl: {
                              hd: Core.seq({
                                    hd: not_empty,
                                    tl: {
                                      hd: enclosed_set(true, false, kind, set),
                                      tl: /* [] */0
                                    }
                                  }),
                              tl: /* [] */0
                            }
                          }));
          };
          var _state = state;
          while(true) {
            var state$1 = _state;
            var match = next(state$1);
            if (match === undefined) {
              return append(undefined, state$1, maybe_empty);
            }
            var c = match[0];
            if (typeof c === "number") {
              switch (c) {
                case /* One */0 :
                    return append(undefined, match[1], not_empty);
                case /* Many */1 :
                    _state = match[1];
                    continue ;
                case /* ManyMany */2 :
                    return many_many(match[1]);
                
              }
            } else {
              switch (c.TAG | 0) {
                case /* Exactly */0 :
                    var c$1 = c._0;
                    var state$2 = append(undefined, match[1], c$1 === /* '.' */46 ? not_empty : maybe_empty);
                    return exactly(state$2, c$1);
                case /* Any_of */1 :
                    return enclosed_set$1(match[1], "Any_of", c._0);
                case /* Any_but */2 :
                    return enclosed_set$1(match[1], "Any_but", c._0);
                
              }
            }
          };
      case /* ManyMany */2 :
          return many_many(state);
      
    }
  } else {
    switch (piece$1.TAG | 0) {
      case /* Exactly */0 :
          return exactly(state, piece$1._0);
      case /* Any_of */1 :
          return append(undefined, state, enclosed_set(explicit_slash, explicit_period$1, "Any_of", piece$1._0));
      case /* Any_but */2 :
          return append(undefined, state, enclosed_set(explicit_slash, explicit_period$1, "Any_but", piece$1._0));
      
    }
  }
}

function glob(pathname, period, glob$1) {
  var _state = create(period, pathname, glob$1);
  while(true) {
    var state = _state;
    var match = next(state);
    if (match === undefined) {
      return Core.seq(List.rev(state.re_pieces));
    }
    _state = piece(match[1], match[0]);
    continue ;
  };
}

function glob$1(anchoredOpt, pathnameOpt, periodOpt, expand_bracesOpt, double_asteriskOpt, s) {
  var anchored = anchoredOpt !== undefined ? anchoredOpt : false;
  var pathname = pathnameOpt !== undefined ? pathnameOpt : true;
  var period = periodOpt !== undefined ? periodOpt : true;
  var expand_braces = expand_bracesOpt !== undefined ? expand_bracesOpt : false;
  var double_asterisk = double_asteriskOpt !== undefined ? double_asteriskOpt : true;
  var to_re = function (s) {
    var re = glob(pathname, period, of_string(double_asterisk, s));
    if (anchored) {
      return Core.whole_string(re);
    } else {
      return re;
    }
  };
  if (expand_braces) {
    return Core.alt(List.map(to_re, explode(s)));
  } else {
    return to_re(s);
  }
}

function glob$p(anchored, period, s) {
  return glob$1(anchored, undefined, period, undefined, undefined, s);
}

function globx(anchored, s) {
  return glob$1(anchored, undefined, undefined, true, undefined, s);
}

function globx$p(anchored, period, s) {
  return glob$1(anchored, undefined, period, true, undefined, s);
}

export {
  Parse_error ,
  glob$1 as glob,
  glob$p ,
  globx ,
  globx$p ,
  
}
/* Core Not a pure module */
